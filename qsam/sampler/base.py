# AUTOGENERATED! DO NOT EDIT! File to edit: 06b_sampler.base.ipynb (unless otherwise specified).

__all__ = ['ranges_from_probs', 'circuit_subset_occurence', 'protocol_subset_occurence', 'locgrp_wgts_combis',
           'protocol_locgrp_wgts_combis', 'locgrp_lens', 'Sampler']

# Cell
from .tree import CountTree, Variable, Constant

from ..callbacks import CallbackList
from tqdm.auto import tqdm
import itertools as it
import numpy as np
import qsam.math as math
from ..noise import E0

from collections.abc import Iterable
from collections import OrderedDict

# Cell

locgrp_lens = lambda locgrps: [len(locgrp) for locgrp in locgrps.values()]

def ranges_from_probs(locgrp_probs):

    if isinstance(locgrp_probs, dict):
        locgrp_probs = list(locgrp_probs.values())

    prob_lists = [p if isinstance(p, Iterable) else [p] for p in locgrp_probs]
    targ_len = max([len(prob_list) for prob_list in prob_lists])

    pad = lambda lst,e: np.append(lst, [e] * (targ_len - len(lst))) if len(lst) < targ_len else lst
    prob_lists = np.array([pad(prob_list,prob_list[-1]) for prob_list in prob_lists])

    return prob_lists.T

def circuit_subset_occurence(locgrps: dict, locgrps_wgts_combis: list, locgrp_probs: (dict,list)) -> np.ndarray:
    """Return matrix of dims (locgrp_wgts)x(probs_range), i.e. the binomial weights
    for each location group weight (rows) and the corresponding physical error rates (columns)."""
    # assert len(locgrps) == len(locgrp_probs), f"Must specify probabilities for all location groups ({len(locgrps)}). Received ({len(locgrp_probs)}) values."

    probs_ranges = ranges_from_probs(locgrp_probs)
    Aws = np.array([math.binom(np.array(locgrp_wgts), np.array(locgrp_lens(locgrps)), probs_ranges) for locgrp_wgts in locgrps_wgts_combis])
    Aws = np.product(Aws, axis=-1)
    return Aws

def protocol_subset_occurence(protocol_locgrps: dict, protocol_locgrp_wgts_combis: dict, locgrp_probs: (dict,list)) -> dict:
    """Generate subset occurence probabilities corresponding to each subset weight
    combination per circuit location group in `locgrp` in protocol."""

    return {cid: {wgts_vec: Aw for wgts_vec, Aw in zip(wgts_combis, circuit_subset_occurence(protocol_locgrps[cid], wgts_combis, locgrp_probs))}
            for cid, wgts_combis in protocol_locgrp_wgts_combis.items()}

def locgrp_wgts_combis(locgrps: dict) -> list:
    """Return list of all possible location group weight vector combinations."""
    return list(it.product( *[tuple(range(N+1)) for N in locgrp_lens(locgrps)] ))

def protocol_locgrp_wgts_combis(protocol_locgrps: dict) -> dict:
    """Generate all possible location group weight vector combinations
    for each circuit in a given protocol."""

    return {cid: locgrp_wgts_combis(locgrps) for cid, locgrps in protocol_locgrps.items()}

# Cell
class Sampler:

    def __init__(self, protocol, simulator, err_model=E0):
        self.protocol = protocol
        self.simulator = simulator
        self.n_qubits = protocol.n_qubits
        self.err_model = err_model
        self.trees = OrderedDict()
        self.protocol_locgrps = {cid: err_model.group(circuit) for cid, circuit in self.protocol._circuits.items()}
        self.protocol_wgts_combis = protocol_locgrp_wgts_combis(self.protocol_locgrps)

    def optimize(self, tree_node, circuit):
        """Must be overwritten by child class."""
        raise NotImplemented

    def run(self, n_samples: int, err_params: (dict,list), callbacks=[]) -> None:
        assert isinstance(err_params, (dict,list)), "`err_params` must be either dict or list."
        assert len(err_params) == len(self.err_model.groups), "`err_params` must have same length as `groups` defined in error model."
        prob_vecs = ranges_from_probs(err_params)

        if not isinstance(callbacks, CallbackList):
            callbacks = CallbackList(sampler=self, callbacks=callbacks)
        callbacks.on_sampler_begin()

        for prob_vec in tqdm(prob_vecs, desc="Total"):
            self.stop_sampling = False

            self.tree_idx = tuple(prob_vec)
            tree = self.trees.get(self.tree_idx, CountTree(min_path_weight=2 if self.protocol._ft else 1))
            self.trees[self.tree_idx] = tree
            tree.constants = protocol_subset_occurence(self.protocol_locgrps, self.protocol_wgts_combis, prob_vec)

            for _ in tqdm(range(n_samples), desc=f'p_phy={",".join(list(f"{p:.2E}" for p in prob_vec))}', leave=True):
                callbacks.on_protocol_begin()

                state = self.simulator(self.n_qubits)
                tree_node = None

                for name, circuit in self.protocol:
                    callbacks.on_circuit_begin()

                    tree_node = tree.add(name=name, parent=tree_node, nodetype=Variable)
                    tree_node.counts += 1
                    opt_out = dict()

                    if circuit:
                        if not circuit._noisy:
                            msmt = state.run(circuit)
                        else:
                            opt_out = self.optimize(tree_node, circuit, prob_vec)
                            tree_node = tree.add(name=opt_out['grp_wgts'], parent=tree_node, nodetype=Constant, cid=circuit.id,
                                                 is_deterministic=True if circuit._ff_det and not any(opt_out['grp_wgts']) else False)
                            tree_node.counts += 1
                            fault_circuit = self.err_model.run(circuit, opt_out['flocs'])

                            msmt = state.run(circuit, fault_circuit)
                        self.protocol.send(msmt)

                    elif name != None:
                        tree_node.marked = True

                    callbacks.on_circuit_end(locals() | opt_out)

                callbacks.on_protocol_end()
                if self.stop_sampling: break

        callbacks.on_sampler_end()