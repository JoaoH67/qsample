# AUTOGENERATED! DO NOT EDIT! File to edit: 02_protocol.ipynb (unless otherwise specified).

__all__ = ['Protocol', 'draw_protocol', 'iterate', 'save_protocol', 'load_protocol']

# Cell
import networkx as nx
from .circuit import make_hash, Circuit
from functools import lru_cache
import pickle
import simpleeval

import matplotlib.lines as mlines
import matplotlib.pyplot as plt

# Cell
class Protocol(nx.DiGraph):
    """Representation of a Quantum Error Correction protocol"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._circuits = {} # hash table
        self._check_fns = simpleeval.DEFAULT_FUNCTIONS.copy()
        self._check_fns.update(len=len, bin=bin)

    def add_node(self, name, circuit):
        circuit_hash = make_hash(circuit)
        self._circuits[circuit_hash] = circuit
        super().add_node(name, circuit_hash=circuit_hash)

    def update_node(self, node, circuit):
        circuit_hash = make_hash(circuit)
        self._circuits[circuit_hash] = circuit
        self.nodes[node]['circuit_hash'] = circuit_hash

    def add_nodes_from(self, names, circuits):
        if not isinstance(circuits, (list,tuple,set)):
            circuits = [circuits] * len(names)
        for name, circuit in zip(names, circuits):
            self.add_node(name, circuit)

    def circuit_from_node(self, node):
        circuit_hash = self.circuit_hash(node)
        circuit = self._circuits[circuit_hash]
        return circuit_hash, circuit

    def circuit_hash(self, node):
        return self.nodes(data='circuit_hash')[node]

    @lru_cache(maxsize=128)
    def checks(self, node):
        adj_nodes = self.out_edges(node)
        return {pair[1]: self.edges[pair]['check'] for pair in adj_nodes}

# Cell
def draw_protocol(protocol, save_path=None, figsize=(6,4), layout=nx.kamada_kawai_layout, edge_legend=False, self_loop_offset=(0.03,0.06), color=True):
    """Draw graph representation of protocol"""

    plt.figure(figsize=figsize)

    pos = layout(protocol)

    nudge = lambda pos, x_shift, y_shift: {n:(x + x_shift, y + y_shift) for n,(x,y) in pos.items()}
    n_pos = nudge(pos, *self_loop_offset) # offset labels for self-loops

    if color:
        col_vals = []
        for node in protocol.nodes:
            if not protocol.in_edges(node): col_vals.append('#99ccff')
            elif not protocol.out_edges(node): col_vals.append('#ff9999')
            else: col_vals.append('#ffb266')
    else: col_vals = 'white'

    node_sizes = max([len(node_str)**2 * 100 for node_str in pos.keys()])
    nx.draw(protocol, pos=pos, with_labels=True, node_color=col_vals, node_size=node_sizes, edgecolors='black')

    edge_labels = nx.get_edge_attributes(protocol, 'check')
    if edge_legend:
        n_edge_labels = dict()
        legend_labels = []

        cnt = 0
        for k,v in edge_labels.items():
            if v == 'True':
                n_edge_labels[k] = v
            else:
                i = n_edge_labels.get(k, None)
                if not i:
                    i = cnt
                    cnt += 1

                n_edge_labels[k] = f'${i}$'
                legend_elem = mlines.Line2D([], [], color='black', marker=f'${i}$', linestyle='None', markersize=8, label=v)
                legend_labels.append(legend_elem)

        lgd = plt.legend(handles=legend_labels, bbox_to_anchor=(1.04, 1), loc="upper left")
        edge_labels = n_edge_labels

    edge_labels_self_loops = {(to,fr): lbl for (to,fr), lbl in edge_labels.items() if to == fr}
    edge_labels_no_loops = {(to,fr): lbl for (to,fr), lbl in edge_labels.items() if to != fr}

    rotate = False if edge_legend else True

    for ps, lbls in zip([pos,n_pos], [edge_labels_no_loops, edge_labels_self_loops]):
        nx.draw_networkx_edge_labels(protocol, ps, lbls, font_size=12, bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=0.3'), rotate=rotate)

    if save_path and edge_legend: plt.savefig(save_path, bbox_extra_artists=(lgd,), bbox_inches='tight')
    elif save_path: plt.savefig(save_path, bbox_inches='tight')


# Cell
def iterate(protocol):
    """Iterator over protocol"""

    hist = {}
    node = "START"
    name_handler = lambda ast_node: hist.get(ast_node.id, None)

    while True:
        checks = {n: simpleeval.simple_eval(check, names=name_handler, functions=protocol._check_fns)
                  for n,check in protocol.checks(node).items()}
        next_nodes = [(nn,check) for nn,check in checks.items() if check]

        if len(next_nodes) == 0:
            yield None
        elif len(next_nodes) == 1:
            node, check_ret = next_nodes[0]

            if isinstance(check_ret, Circuit): # check return can be Circuit in case of COR nodes.
                protocol.update_node(node, check_ret)

            msmt = yield node
            if msmt: msmt = int(msmt,2) # string to int
            hist[node] = hist.get(node,[]) + [msmt]
        else:
            raise Exception(f"Too many checks True for node {node}.")

# Cell
def save_protocol(protocol, fname, path='.'):
    """Saves a protocol to `path` with file name `fname`"""
    file = open(f'{path}/{fname}.proto', 'wb')
    pickle.dump(protocol,file)
    file.close()

# Cell
def load_protocol(fname, path='.'):
    """Loads a protocol from `path` with file name `fname`"""
    file = open(f'{path}/{fname}.proto', 'rb')
    res = pickle.load(file)
    file.close()
    return res