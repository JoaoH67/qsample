# AUTOGENERATED! DO NOT EDIT! File to edit: 02_protocol.ipynb (unless otherwise specified).

__all__ = ['Protocol', 'draw_protocol', 'cached_eval', 'iterate']

# Cell
import networkx as nx
from re import sub
from .circuit import make_hash
from functools import lru_cache

# Cell
class Protocol(nx.DiGraph):
    """Representation of a Quantum Error Correction protocol"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._circuits = {} # hash table

    def add_node(self, name, circuit):
        circuit_hash = make_hash(circuit)
        self._circuits[circuit_hash] = circuit
        super().add_node(name, circuit_hash=circuit_hash)

    def add_nodes_from(self, names, circuits):
        if not isinstance(circuits, (list,tuple,set)):
            circuits = [circuits] * len(names)
        for name, circuit in zip(names, circuits):
            self.add_node(name, circuit)

    @lru_cache(maxsize=128)
    def circuit_hash(self, node):
        return self.nodes(data='circuit_hash')[node]

    @lru_cache(maxsize=128)
    def checks(self, node):
        adj_nodes = self.out_edges(node)
        return {pair[1]: self.edges[pair]['check'] for pair in adj_nodes}

# Cell
def draw_protocol(protocol):
    """Draw graph representation of protocol"""

    pos = nx.kamada_kawai_layout(protocol)
    col_val_map = {'START': '#99ccff', 'EXIT': '#ff9999'}
    col_vals = [col_val_map.get(node, '#ffb266') for node in protocol.nodes]
    nx.draw(protocol, pos, node_color=col_vals, with_labels=True, node_size=1200)#, font_color='white')
    edge_labels = nx.get_edge_attributes(protocol, 'check')
    nx.draw_networkx_edge_labels(protocol, pos, edge_labels)

# Cell
#hide
@lru_cache(maxsize=256)
def cached_eval(eval_str):
    return eval(eval_str)

# Cell
def iterate(protocol):
    """Iterator over protocol"""

    hist = {}
    node = "START"
    repl_fn = lambda match: hist.get(match.group(1), "None")
    eval_check = lambda check: cached_eval(sub("`(.*?)`", repl_fn, check))

    while True:
        checks = protocol.checks(node)
        next_nodes = [n for n,c in checks.items() if eval_check(c)]
        if len(next_nodes) == 0:
            yield None
        elif len(next_nodes) == 1:
            node = next_nodes[0]
            hist[node] = yield node
        else:
            raise Exception(f"Too many checks True for node {node}.")