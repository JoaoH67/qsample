# AUTOGENERATED! DO NOT EDIT! File to edit: 05_samplers.ipynb (unless otherwise specified).

__all__ = ['ONE_QUBIT_GATES', 'TWO_QUBIT_GATES', 'GATE_GROUPS', 'map_dict', 'Sampler', 'calc_w_max',
           'calc_subset_occurances', 'SubsetSampler']

# Cell
import qsam.math as math
from .circuit import partition, make_hash
from .simulators.chp import CHP
from .fault_generators import Depolar, DepolarSS
from .protocol import iterate

import numpy as np
import itertools as it
import networkx as nx

# Cell
ONE_QUBIT_GATES = {'H', 'X', 'Z'}
TWO_QUBIT_GATES = {'CNOT'}

GATE_GROUPS = {'p': ONE_QUBIT_GATES | TWO_QUBIT_GATES,
               'p1': ONE_QUBIT_GATES,
               'p2': TWO_QUBIT_GATES }

map_dict = lambda d, map_fn: {k: map_fn(k,v) for k,v in d.items()} # apply map_fn to vals

# Cell
class Sampler:
    def __init__(self, protocol, err_params):
        self.protocol = protocol
        self.p_phy_per_partition = np.vstack(list(err_params.values())).T
        self.partitions = map_dict(protocol._circuits, lambda _,circuit: [partition(circuit, GATE_GROUPS[g]) for g in err_params.keys()])
        self.fault_gens = map_dict(protocol._circuits, lambda _,circuit: Depolar(len(circuit)))

    def _sample(self, circuit_hash, p_or_w):
        partitions = self.partitions[circuit_hash]
        fault_gen = self.fault_gens[circuit_hash]
        fault_circuit = fault_gen.generate(partitions, p_or_w)
        circuit = self.protocol._circuits[circuit_hash]
        sim = CHP(circuit.n_qubits)
        msmt = sim.run(circuit, fault_circuit)
        return msmt

    def run(self, n_samples, var=math.Wilson_var):
        fail_cnts = np.zeros((self.p_phy_per_partition.shape[0])) # one fail counter per p_phys

        for i, p_phy in enumerate(self.p_phy_per_partition):
            for _ in range(n_samples):
                p_it = iterate(self.protocol)
                node = next(p_it)

                while node:
                    if node == 'EXIT':
                        fail_cnts[i] += 1
                        break
                    else:
                        circuit_hash = self.protocol.circuit_hash(node)
                        msmt = self._sample(circuit_hash, p_phy)
                        node = p_it.send(msmt)

        p_L = fail_cnts / n_samples
        std = np.sqrt( var(p_L, n_samples) )
        return p_L, std

# Cell
#export
def calc_w_max(p_max, delta_max, n_partition_elems):
    """Calculate weight cutoff at p_max for delta_max"""

    delta = 1
    for w_max in range(n_partition_elems+1):
        delta -= math.binom(w_max, n_partition_elems, p_max)
        if delta < delta_max:
            break
    return w_max

def calc_subset_occurances(partitions, partition_w_vecs, p_phy_per_partition):
    """Return (weight)x(p_phys) (parition) subset occurance matrix transforming a p_SS vector to a p_L vector"""

    n_partition_elems = np.array([len(p) for p in partitions])
    Aws = np.array([math.binom(w_vec, n_partition_elems, p_phy_per_partition) for w_vec in partition_w_vecs])
    Aws = np.product(Aws, axis=-1) # mult Aws for multi-parameter, i.e. multi-partitions
    return Aws

# Cell
class SubsetSampler(Sampler):
    """Subset Sampler of quantum protocols"""

    def __init__(self, protocol, err_params):
        super().__init__(protocol, err_params)
        self.fault_gens = map_dict(protocol._circuits, lambda _,circuit: DepolarSS(len(circuit)))

    def analytics(self, w_maxs, w_exclude={}):
        w_exclude = set((w,) if isinstance(w,int) else w for w in w_exclude)
        w_maxs = [w_maxs] if isinstance(w_maxs, int) else w_maxs

        w_upto_w_maxs = {c_hash: [tuple(range(w_max+1)) for w_max in w_maxs] for c_hash in self.protocol._circuits.keys()} # order [p1,p2,..]
        w_vecs = map_dict(w_upto_w_maxs, lambda _,w_list: [w_vec for w_vec in it.product( *w_list ) if w_vec not in w_exclude])
        Aws = map_dict(w_vecs, lambda c,w: calc_subset_occurances(self.partitions[c], w, self.p_phy_per_partition))
        return Aws, w_vecs

    def run(self, n_samples, w_max, w_exclude={}, var=math.Wilson_var):

        Aws, w_vecs = self.analytics(w_max, w_exclude)

        d = {n:c for n,c in self.protocol.nodes.data("circuit_hash", default=None) if c}
        visited_cnts     = map_dict(d, lambda _,c_hash: np.zeros(len(w_vecs[c_hash])))
        transition_cnts = map_dict(d, lambda node,c_hash: {s: np.zeros(len(w_vecs[c_hash])) for s in self.protocol.successors(node)})

        sample_graph = nx.DiGraph() # graph holding all fail paths

        for _ in range(n_samples):
            hist = [] # track all (node,weight)s for a protocol run
            p_it = iterate(self.protocol)
            node = next(p_it)

            while node:
                if node == "EXIT":
                    nodes = ["START"] + hist + ["EXIT"]
                    for i in range(len(nodes)-1): # add fail path
                        sample_graph.add_edge(nodes[i], nodes[i+1])
                    break
                else:
                    circuit_hash = self.protocol.circuit_hash(node)
                    w_idx = visited_cnts[node].argmin() # balanced weight selector
                    w = w_vecs[circuit_hash][w_idx]
                    hist.append((node,w_idx))
                    msmt = self._sample(circuit_hash, w)
                    visited_cnts[node][w_idx] += 1
                    _node = node # store prev node
                    node = p_it.send(msmt) # exchange with iterator
                    if node: # None: insignificant exit -> no transition
                        transition_cnts[_node][node][w_idx] += 1

        # Calculate statistics

        fail_paths = list(nx.all_simple_paths(sample_graph, 'START', 'EXIT'))
        pws = {n: {succ: tcnts / visited_cnts[n] for succ,tcnts in ntrans.items()} for n,ntrans in transition_cnts.items()}
        unpack_node = lambda n: n if not isinstance(n,(tuple,list,set)) else n[0]

        # p_L_low
        p_L_low = 0
        for path in fail_paths:
            prod_acc = 1
            for i in range(1,len(path)-1):
                node, weight = path[i]
                succ_node = unpack_node(path[i+1])
                circuit_hash = self.protocol.circuit_hash(node)
                prod_acc *= Aws[circuit_hash][weight] * pws[node][succ_node][weight]
            p_L_low += prod_acc

        # p_L_up
#         delta = 1
#         for path in fail_paths:
#             prod_acc = 1
#             for i in range(1,len(path)-1):
#                 node, _ = path[i]
#                 succ_node = unpack_node(path[i])
#                 circuit_hash = self.protocol.circuit_hash(node)
#                 for w_idx in range(len(w_vecs[circuit_hash])):
#                     prod

#         p_L_up = p_L_low + delta

        # v_L
        v_L = 0
        for path in fail_paths:
            for i in range(1,len(path)-1):
                node1, weight1 = path[i]
                succ_node1 = unpack_node(path[i+1])
                circuit_hash1 = self.protocol.circuit_hash(node1)

                prod_acc = 1
                for j in range(1,len(path)-1):
                    node2, weight2 = path[j]
                    succ_node2 = unpack_node(path[j+1])
                    circuit_hash2 = self.protocol.circuit_hash(node2)
                    if (node1,weight1) != (node2,weight2):
                        prod_acc *= Aws[circuit_hash2][weight2] * pws[node2][succ_node2][weight2]

                vws = var(pws[node1][succ_node1][weight1], visited_cnts[node1][weight1])
                v_L += vws * Aws[circuit_hash1][weight1]**2 * prod_acc**2

        return p_L_low, np.sqrt(v_L)