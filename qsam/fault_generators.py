# AUTOGENERATED! DO NOT EDIT! File to edit: 04_fault_generators.ipynb (unless otherwise specified).

__all__ = ['Depolar', 'ONE_QUBIT_FAULTS', 'TWO_QUBIT_FAULTS']

# Cell
from .circuit import Circuit
import numpy as np
import itertools as it

# Cell

ONE_QUBIT_FAULTS = ["X", "Y", "Z"]
TWO_QUBIT_FAULTS = list(it.product(ONE_QUBIT_FAULTS + ["I"], repeat=2))
TWO_QUBIT_FAULTS.remove(("I","I"))

class Depolar:

    @staticmethod
    def faults_from_probs(partitions, ps):
        """Select fault locs by random number < p for elements in partitions"""
        return [loc for locs,p in zip(partitions, ps) for loc in locs if np.random.random() < p]

    @staticmethod
    def faults_from_weights(partitions, ws):
        """Select fault locs by random choice of w elements per partition"""
        return [par[i] for par,w in zip(partitions,ws) for i in np.random.choice(len(par),w,replace=False)]

    @staticmethod
    def gen_circuit(n_ticks, faults=[]):
        """Generate an empty circuit with given faults"""

        fault_circuit = Circuit([{} for _ in range(n_ticks)])

        for (tick_index,qubit) in faults:
            if isinstance(qubit, int):
                f_gate = np.random.choice(ONE_QUBIT_FAULTS)
                qb_set = fault_circuit[tick_index].get(f_gate, set()) # get previous f_gate type fault
                qb_set.add(qubit) # append faults in this tick
                fault_circuit[tick_index][f_gate] = qb_set # udpate
            elif isinstance(qubit, (list,set,tuple)):
                f_gates = TWO_QUBIT_FAULTS[np.random.choice(len(TWO_QUBIT_FAULTS))]
                for f_gate, qubit_i in zip(f_gates, qubit):
                    if f_gate != "I":
                        qb_set = fault_circuit[tick_index].get(f_gate, set())
                        qb_set.add(qubit_i)
                        fault_circuit[tick_index][f_gate] = qb_set
        return fault_circuit