# AUTOGENERATED! DO NOT EDIT! File to edit: 05a_samplers.circuit_samplers.ipynb (unless otherwise specified).

__all__ = ['ONE_QUBIT_GATES', 'TWO_QUBIT_GATES', 'GATE_GROUPS', 'Sampler', 'SubsetSampler', 'calc_w_max']

# Cell
import qsam.math as math
from ..circuit import partition, make_hash, unpack
from ..fault_generators import Depolar

import numpy as np
import itertools as it

# Cell
ONE_QUBIT_GATES = {'H', 'X', 'Z'}
TWO_QUBIT_GATES = {'CNOT'}

GATE_GROUPS = {'p': ONE_QUBIT_GATES | TWO_QUBIT_GATES,
               'p1': ONE_QUBIT_GATES,
               'p2': TWO_QUBIT_GATES,
               }

# Cell
class Sampler:
    def __init__(self, circuit, simulator):
        self.circuit = circuit
        self.simulator = simulator
        self.n_qubits = circuit.n_qubits

    def run(self, n_samples, sample_range, err_params, fail_patterns, var=math.Wilson_var):
        fail_cnts = np.zeros(len(sample_range))
        partitions = [partition(self.circuit, GATE_GROUPS[k]) for k in err_params.keys()]

        for i, sample_pt in enumerate(sample_range):

            p_phy = np.array(list(err_params.values())) * sample_pt

            for _ in range(n_samples):
                sim = self.simulator(self.n_qubits)
                faults = Depolar.faults_from_probs(partitions, p_phy)
                fault_circuit = Depolar.gen_circuit(len(self.circuit), faults)
                msmt = sim.run(self.circuit, fault_circuit)
                if msmt in fail_patterns:
                    fail_cnts[i] += 1

        p_L = fail_cnts / n_samples
        std = np.sqrt( var(p_L, n_samples) )
        return p_L, std

# Cell

class SubsetSampler:
    def __init__(self, circuit, simulator):
        self.circuit = circuit
        self.simulator = simulator
        self.n_qubits = circuit.n_qubits

    @staticmethod
    def subset_occurence(partitions, partition_w_vecs, p_phy_per_partition):
        """Return (weight)x(p_phys) (parition) subset occurance matrix transforming p_SS vector to p_L vector"""
        n_partition_elems = np.array([len(p) for p in partitions])
        Aws = np.array([math.binom(w_vec, n_partition_elems, p_phy_per_partition) for w_vec in partition_w_vecs])
        Aws = np.product(Aws, axis=-1) # mult Aws for multi-parameter, i.e. multi-partitions
        return Aws

    @staticmethod
    def weight_vectors(w_max, w_exclude={}):
        w_exclude = set((w,) if isinstance(w, int) else w for w in w_exclude)
        w_maxs = [w_max] if isinstance(w_max, int) else w_max

        w_upto_w_maxs = [tuple(range(w_max+1)) for w_max in w_maxs]
        w_vecs = list(it.product( *w_upto_w_maxs ))
        return w_vecs

    def run(self, n_samples, sample_range, err_params, fail_patterns, w_max, w_exclude, var=math.Wilson_var):

        p_phy_per_partition = np.array([[p_phy * mul for p_phy in sample_range] for mul in err_params.values()]).T
        partitions =[partition(self.circuit, GATE_GROUPS[k]) for k in err_params.keys()]

        w_vecs = SubsetSampler.weight_vectors(w_max, w_exclude)
        Aws = SubsetSampler.subset_occurence(partitions, w_vecs, p_phy_per_partition)

        cnts = np.zeros((len(w_vecs))) + 1 # one virtual sample to avoid div0
        fail_cnts = np.zeros((len(w_vecs)))

        for i in range(n_samples):
            sim = self.simulator(self.n_qubits)
            ss_idx = cnts.argmin()
            w_vec = w_vecs[ss_idx]
            faults = Depolar.faults_from_weights(partitions, w_vec)
            fault_circuit = Depolar.gen_circuit(len(self.circuit), faults)
            msmt = sim.run(self.circuit, fault_circuit)
            if msmt in fail_patterns:
                fail_cnts[ss_idx] += 1
            cnts[ss_idx] += 1

        pws = ( fail_cnts / (cnts - 1) )[:,None]

        w_vecs_inclusive = SubsetSampler.weight_vectors(w_max, {})
        Aws_inclusive = SubsetSampler.subset_occurence(partitions, w_vecs_inclusive, p_phy_per_partition)
        Aws_upper = 1 - np.sum(Aws_inclusive, axis=0)

        p_L_low = np.sum(Aws * pws, axis=0)
        p_L_up = p_L_low + Aws_upper
        std = np.sqrt( np.sum( Aws**2 * var(pws, n_samples), axis=0 ) )

        return p_L_low, p_L_up, std

# Cell
#hide

def calc_w_max(p_max, delta_max, n_partition_elems):
    """Calculate weight cutoff at p_max for delta_max"""

    delta = 1
    for w_max in range(n_partition_elems+1):
        delta -= math.binom(w_max, n_partition_elems, p_max)
        if delta < delta_max:
            break
    return w_max