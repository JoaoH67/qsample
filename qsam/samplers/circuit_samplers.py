# AUTOGENERATED! DO NOT EDIT! File to edit: 05a_samplers.circuit_samplers.ipynb (unless otherwise specified).

__all__ = ['Sampler', 'SubsetSampler', 'calc_w_max']

# Cell
import qsam.math as math
from ..circuit import partition, make_hash, unpack
from ..fault_generators import Depolar
import qsam.samplers.callbacks as cb
from .constants import *
from .subset_helper import *

import numpy as np
import itertools as it
from tqdm.notebook import tqdm

# Cell
class Sampler:
    def __init__(self, circuit, simulator):
        self.circuit = circuit
        self.simulator = simulator
        self.n_qubits = circuit.n_qubits
        self.is_setup = False

    def setup(self, sample_range, err_params):
        self.partitions = [partition(self.circuit, GATE_GROUPS[k]) for k in err_params.keys()]
        self.p_phys = [s * np.array(list(err_params.values())) for s in sample_range]

        self.cnts = np.zeros(len(sample_range))
        self.fail_cnts = np.zeros(len(sample_range))
        self.is_setup = True

    def stats(self, p_idx=None, var_fn=math.Wilson_var, **kwargs):
        if p_idx == None:
            rate = self.fail_cnts / self.cnts
            var = var_fn(rate, self.cnts)
        else:
            rate = self.fail_cnts[p_idx] / self.cnts[p_idx]
            var = var_fn(rate, self.cnts[p_idx])

        return rate, np.sqrt(var), 0.0

    def run(self, n_samples, callbacks=[]):
        assert self.is_setup, 'Sampler not setup. Call setup(..) before run(..).'

        if not isinstance(callbacks, cb.CallbackList):
            callbacks = cb.CallbackList(sampler=self, callbacks=callbacks)
        callbacks.on_sampler_begin()

        for i, p_phy in enumerate(tqdm(self.p_phys, desc='Total')):
            self.stop_sampling = False
            self.p_idx = i

            for _ in tqdm(range(n_samples), desc=f'p_phy={",".join(list(f"{p:.2E}" for p in p_phy))}', leave=True):
                sim = self.simulator(self.n_qubits)
                faults = Depolar.faults_from_probs(self.partitions, p_phy)
                fault_circuit = Depolar.gen_circuit(len(self.circuit), faults)
                msmt = sim.run(self.circuit, fault_circuit)
                if int(msmt,2) in fail_patterns:
                    self.fail_cnts[i] += 1
                self.cnts[i] += 1

                callbacks.on_circuit_end(locals())
                if self.stop_sampling: break

        callbacks.on_sampler_end()

# Cell

class SubsetSampler:
    def __init__(self, circuit, simulator):
        self.circuit = circuit
        self.simulator = simulator
        self.n_qubits = circuit.n_qubits
        self.is_setup = False

    def setup(self, sample_range, err_params, w_max, w_exclude={}, p_max=0.1):
        p_max = np.array([p_max]) if isinstance(p_max, float) else np.array(p_max)
        assert len(p_max) == len(err_params)
        self.partitions = circuit_partitions(self.circuit, err_params.keys())
        self.w_vecs = circuit_weight_vectors(w_max, w_exclude)
        self.err_params = err_params
        self.w_max = w_max
        self.Aws_pmax = circuit_subset_occurence(self.partitions, self.w_vecs, p_max)
        self.Aws_pmax_inclusive = circuit_subset_occurence(self.partitions, circuit_weight_vectors(self.w_max), p_max)
        self.set_range(sample_range)

        self.cnts = np.zeros((len(self.w_vecs))) + 1 # one virtual sample to avoid div0
        self.fail_cnts = np.zeros((len(self.w_vecs)))
        self.is_setup = True

    def set_range(self, sample_range):
        p_phy_per_partition = np.array([[p_phy * mul for p_phy in sample_range] for mul in self.err_params.values()]).T
        self.Aws = circuit_subset_occurence(self.partitions, self.w_vecs, p_phy_per_partition)
        self.Aws_inclusive = circuit_subset_occurence(self.partitions, circuit_weight_vectors(self.w_max,{}), p_phy_per_partition)

    @property
    def ss_rate(self):
        cnts = self.cnts - 1 if np.all(self.cnts > 1) else self.cnts
        return ( self.fail_cnts / (cnts) )[:,None]

    def stats(self, const='Aws', var_fn=math.Wilson_var, **kwargs):
        if const == 'Aws': Aws, Aws_inclusive = self.Aws, self.Aws_inclusive
        elif const == 'Aws_pmax': Aws, Aws_inclusive = self.Aws_pmax[:,None], self.Aws_pmax_inclusive[:,None]
        v_L = np.sum( [Aws[w]**2 * var_fn(self.ss_rate[w], self.cnts[w]) for w in range(len(self.w_vecs))], axis=0 )
        p_L = np.sum(Aws * self.ss_rate, axis=0)
        if isinstance(v_L, np.ndarray) and isinstance(p_L, int):
            p_L = np.zeros_like(v_L)
        delta = 1 - np.sum(Aws_inclusive, axis=0)
        return p_L, np.sqrt(v_L), delta

    def run(self, n_samples, callbacks=[]):
        assert self.is_setup, 'Sampler not setup. Call setup(..) before run(..).'

        if not isinstance(callbacks, cb.CallbackList):
            callbacks = cb.CallbackList(sampler=self, callbacks=callbacks)

        self.stop_sampling = False
        callbacks.on_sampler_begin()

        for i in tqdm(range(n_samples), desc='Total'):

            callbacks.on_circuit_begin()

            sim = self.simulator(self.n_qubits)
            w_idx = self.cnts.argmin() # balanced weight selector
            w_vec = self.w_vecs[w_idx]
            faults = Depolar.faults_from_weights(self.partitions, w_vec)
            fault_circuit = Depolar.gen_circuit(len(self.circuit), faults)
            msmt = sim.run(self.circuit, fault_circuit)
            if int(msmt,2) in fail_patterns:
                self.fail_cnts[w_idx] += 1
            self.cnts[w_idx] += 1

            callbacks.on_circuit_end(locals())
            if self.stop_sampling: break

        callbacks.on_sampler_end()

# Cell
#hide

def calc_w_max(p_max, delta_max, n_partition_elems):
    """Calculate weight cutoff at p_max for delta_max"""

    delta = 1
    for w_max in range(n_partition_elems+1):
        delta -= math.binom(w_max, n_partition_elems, p_max)
        if delta < delta_max:
            break
    return w_max