# AUTOGENERATED! DO NOT EDIT! File to edit: 05b_samplers.protocol_samplers.ipynb (unless otherwise specified).

__all__ = ['ONE_QUBIT_GATES', 'TWO_QUBIT_GATES', 'GATE_GROUPS', 'Sampler', 'SubsetSampler', 'calc_w_max']

# Cell
import qsam.math as math
from ..circuit import partition, make_hash, unpack
from ..fault_generators import Depolar
from ..protocol import iterate

import numpy as np
import itertools as it
import networkx as nx

# Cell
ONE_QUBIT_GATES = {'H', 'X', 'Z'}
TWO_QUBIT_GATES = {'CNOT'}

GATE_GROUPS = {'p': ONE_QUBIT_GATES | TWO_QUBIT_GATES,
               'p1': ONE_QUBIT_GATES,
               'p2': TWO_QUBIT_GATES,
               }

# Cell
class Sampler:
    def __init__(self, protocol, simulator):
        self.protocol = protocol
        self.simulator = simulator
        self.n_qubits = len(set(q for c in protocol._circuits.values() for q in unpack(c)))

    def run(self, n_samples, sample_range, err_params, var=math.Wilson_var, eval_fns=None):

        fail_cnts = np.zeros(len(sample_range)) # one fail counter per sample point
        partitions = {circuit_hash: [partition(circuit, GATE_GROUPS[k]) for k in err_params.keys()]
                     for circuit_hash, circuit in self.protocol._circuits.items()}

        for i,sample_pt in enumerate(sample_range): # n_samples at sample_pt

            p_phy = np.array(list(err_params.values())) * sample_pt

            for _ in range(n_samples):

                sim = self.simulator(self.n_qubits)
                p_it = iterate(self.protocol, eval_fns)
                node = next(p_it)

                while node:

                    if node == 'EXIT':
                        fail_cnts[i] += 1
                        break
                    else:
                        circuit_hash, circuit = self.protocol.circuit_from_node(node)
                        circuit_partitions = partitions[circuit_hash]
                        faults = Depolar.faults_from_probs(circuit_partitions, p_phy)
                        fault_circuit = Depolar.gen_circuit(len(circuit), faults)
                        msmt = sim.run(circuit, fault_circuit)
                        node = p_it.send(msmt)

        p_L = fail_cnts / n_samples
        std = np.sqrt( var(p_L, n_samples) )
        return p_L, std

# Cell
class SubsetSampler:
    """Subset Sampler of quantum protocols"""

    def __init__(self, protocol, simulator):
        self.protocol = protocol
        self.simulator = simulator
        self.n_qubits = len(set(q for c in protocol._circuits.values() for q in unpack(c)))

    @staticmethod
    def subset_occurence(partitions, partition_w_vecs, p_phy_per_partition):
        """Return (weight)x(p_phys) (parition) subset occurance matrix transforming p_SS vector to p_L vector"""
        n_partition_elems = np.array([len(p) for p in partitions])
        Aws = np.array([math.binom(w_vec, n_partition_elems, p_phy_per_partition) for w_vec in partition_w_vecs])
        Aws = np.product(Aws, axis=-1) # mult Aws for multi-parameter, i.e. multi-partitions
        return Aws

    @staticmethod
    def weight_vectors(w_max, w_exclude={}):
        w_exclude = set((w,) if isinstance(w, int) else w for w in w_exclude)
        w_maxs = [w_max] if isinstance(w_max, int) else w_max

        w_upto_w_maxs = [tuple(range(w_max+1)) for w_max in w_maxs]
        w_vecs = list(it.product( *w_upto_w_maxs ))
        return w_vecs

    def run(self, n_samples, sample_range, err_params, w_max, w_exclude={}, var=math.Wilson_var, eval_fns={}):

        p_phy_per_partition = np.array([[p_phy * mul for p_phy in sample_range] for mul in err_params.values()]).T
        partitions = {circuit_hash: [partition(circuit, GATE_GROUPS[k]) for k in err_params.keys()]
                     for circuit_hash, circuit in self.protocol._circuits.items()}
        w_maxs = {circuit_hash: [len(par) if w_max > len(par) else w_max for par in pars]
                  for circuit_hash, pars in partitions.items()}

        circuit_hashes = list(self.protocol._circuits.keys())
        w_vecs = {circuit_hash: SubsetSampler.weight_vectors(w_m, w_exclude)
                 for circuit_hash, w_m in w_maxs.items()}
        Aws = {circuit_hash: SubsetSampler.subset_occurence(partitions[circuit_hash], w_vecs[circuit_hash], p_phy_per_partition)
              for circuit_hash in circuit_hashes}

        node_hash = [(node, circuit_hash) for node, circuit_hash in self.protocol.nodes.data("circuit_hash", default=None) if circuit_hash]
        visited_cnts = {node: np.zeros(len(w_vecs[circuit_hash]))
                       for node, circuit_hash in node_hash}
        transition_cnts = {nodeA: {nodeB: np.zeros(len(w_vecs[circuit_hashA]))
                                  for nodeB in self.protocol.successors(nodeA)}
                          for nodeA, circuit_hashA in node_hash}

        for _ in range(n_samples):
            hist = [] # track all (node,weight)s for a protocol run
            p_it = iterate(self.protocol, eval_fns)
            node = next(p_it)
            sim = self.simulator(self.n_qubits)

            while node:
                if node == "EXIT":
                    break
                else:
                    circuit_hash, circuit = self.protocol.circuit_from_node(node)
                    ss_idx = visited_cnts[node].argmin() # balanced weight selector
                    w_vec = w_vecs[circuit_hash][ss_idx]
                    hist.append((node, ss_idx))

                    faults = Depolar.faults_from_weights(partitions[circuit_hash], w_vec)
                    fault_circuit = Depolar.gen_circuit(len(circuit), faults)
                    msmt = sim.run(circuit, fault_circuit)

                    _node = node # store previous node
                    node = p_it.send(msmt) # exchange with iterator
                    if node: # None: insignificant exit -> no transition
                        transition_cnts[_node][node][ss_idx] += 1
                    visited_cnts[_node][ss_idx] += 1

        # Calculate statistics

        pws = {n: {succ: tcnts / visited_cnts[n] for succ,tcnts in ntrans.items()} for n,ntrans in transition_cnts.items()}
        unpack_node = lambda n: n if not isinstance(n,(tuple,list,set)) else n[0]

        # p_L_up, p_L_low
        p_L_up, p_L_low = 0, 0
        fail_paths = list(nx.all_simple_paths(self.protocol, 'START', 'EXIT'))

        w_vecs_wo_excl = {circuit_hash: SubsetSampler.weight_vectors(w_m, w_exclude)
                         for circuit_hash, w_m in w_maxs.items()}
        Aws_wo_excl = {circuit_hash: SubsetSampler.subset_occurence(partitions[circuit_hash], w_vecs_wo_excl[circuit_hash], p_phy_per_partition)
                      for circuit_hash in circuit_hashes}

        # HOW TO CORRECTLY TRACK PURE MEASUREMENT CIRCUITS?
        for path in fail_paths:
            p_L_up_prod_acc = 1
            p_L_low_prod_acc = 1
            for i in range(1,len(path)-1):
                node, succ_node = path[i:i+2]
                circuit_hash = self.protocol.circuit_hash(node)
                pw = np.sum([Aws[circuit_hash][w] * pws[node][succ_node][w] for w in range(len(w_vecs[circuit_hash]))], axis=0)
                deltas = 1 - np.sum([Aws_wo_excl[circuit_hash][w] for w in range(len(w_vecs_wo_excl[circuit_hash]))], axis=0)
                p_L_low_prod_acc *= pw
                p_L_up_prod_acc *= (pw + deltas)
            p_L_up += p_L_up_prod_acc
            p_L_low += p_L_low_prod_acc

        # v_L
        v_L = 0
        for nodeA, p_to in pws.items(): # for every node in pws
            c_hashA = self.protocol.circuit_hash(nodeA)
            for succ_node, ps in p_to.items(): # get the pws
                for w_idx, pw in enumerate(ps): # get pw per node

                    vw = var(pw, visited_cnts[nodeA][w_idx]) # calc. V[pw]
                    Aw = Aws[c_hashA][w_idx] # calc. Aw for a single node

                    sum_acc = 0 # sum over all fail paths
                    for path in fail_paths:
                        prod_acc = 1
                        for i in range(1,len(path)-1): # all nodes in a fail path
                            nodeB, nodeB_succ = path[i:i+2]
                            if nodeA != nodeB:
                                c_hashB = self.protocol.circuit_hash(nodeB)
                                prod_acc *= np.sum([Aws[c_hashB][w] * pws[nodeB][nodeB_succ][w] for w in range(len(w_vecs[c_hashB]))], axis=0)
                        sum_acc += prod_acc

                    v_L += vw * Aw**2 * sum_acc**2

        return p_L_low, p_L_up, np.sqrt(v_L)

# Cell
#hide

def calc_w_max(p_max, delta_max, n_partition_elems):
    """Calculate weight cutoff at p_max for delta_max"""

    delta = 1
    for w_max in range(n_partition_elems+1):
        delta -= math.binom(w_max, n_partition_elems, p_max)
        if delta < delta_max:
            break
    return w_max