# AUTOGENERATED! DO NOT EDIT! File to edit: 05b_samplers.protocol_samplers.ipynb (unless otherwise specified).

__all__ = ['ONE_QUBIT_GATES', 'TWO_QUBIT_GATES', 'GATE_GROUPS', 'Sampler', 'SubsetSampler']

# Cell
import qsam.math as math
from ..circuit import partition, make_hash, unpack
from ..fault_generators import Depolar
from ..protocol import iterate
from .sampler_mixins import SubsetAnalytics
from .datatypes import CountNode, SampleTree

import numpy as np
from tqdm.notebook import tqdm

# Cell
ONE_QUBIT_GATES = {'H', 'X', 'Z'}
TWO_QUBIT_GATES = {'CNOT'}

GATE_GROUPS = {'p': ONE_QUBIT_GATES | TWO_QUBIT_GATES,
               'p1': ONE_QUBIT_GATES,
               'p2': TWO_QUBIT_GATES,
               }

# Cell

class Sampler:
    def __init__(self, protocol, simulator):
        self.protocol = protocol
        self.simulator = simulator
        self.n_qubits = len(set(q for c in protocol._circuits.values() for q in unpack(c)))

    def run(self, n_samples, sample_range, err_params, RSE_target=1e-1, var=math.Wilson_var, eval_fns=None, verbose=False):

        # RSE: rel. standard error target
        cnts = np.zeros(len(sample_range))
        fail_cnts = np.zeros(len(sample_range)) # one fail counter per sample point
        partitions = {circuit_hash: [partition(circuit, GATE_GROUPS[k]) for k in err_params.keys()]
                     for circuit_hash, circuit in self.protocol._circuits.items()}

        for i in tqdm(range(len(sample_range)), desc='Total'): # n_samples per sample_pt

            p_phy = np.array(list(err_params.values())) * sample_range[i]

            for _ in tqdm(range(n_samples), desc=f'p_phy={",".join(list(f"{p:.2E}" for p in p_phy))}', leave=True):

                sim = self.simulator(self.n_qubits)
                p_it = iterate(self.protocol, eval_fns)
                node = next(p_it)
                cnts[i] += 1

                if verbose: print(f'--- Protocol run {j} ---')

                while node:

                    if not self.protocol.out_edges(node):
                        fail_cnts[i] += 1
                        break

                    circuit_hash, circuit = self.protocol.circuit_from_node(node)
                    if not circuit._noisy or circuit_hash not in partitions.keys():
                        msmt = sim.run(circuit)
                    else:
                        circuit_partitions = partitions[circuit_hash]
                        faults = Depolar.faults_from_probs(circuit_partitions, p_phy)
                        fault_circuit = Depolar.gen_circuit(len(circuit), faults)
                        msmt = sim.run(circuit, fault_circuit)
                    _node = node
                    node = p_it.send(msmt if msmt==None else int(msmt,2))

                    if verbose:
                        pauli_faults = [] if not circuit._noisy else [f'Tick {tick} :: {fault_circuit[tick]}' for tick,_ in faults]
                        if _node == 'COR': print(f"Node {_node}, Circuit {circuit} -> {node}")
                        else: print(f"Node {_node}, Faults {pauli_faults}, Measured {msmt}-> {node}")

                p_L = fail_cnts[i] / cnts[i]
                if p_L != 0 and np.sqrt( var(p_L, cnts[i]) ) / p_L < RSE_target:
                    print(f'RSE target of {RSE_target} reached.')
                    break

        p_L = fail_cnts / cnts
        std = np.sqrt( var(p_L, cnts) )

        return p_L, std

# Cell

class SubsetSampler(SubsetAnalytics):
    """Subset Sampler of quantum protocols"""

    def __init__(self, protocol, simulator, tree=None):
        self.protocol = protocol
        self.simulator = simulator
        self.n_qubits = len(set(q for c in protocol._circuits.values() for q in unpack(c)))
        self.tree = SampleTree()

    def setup(self, sample_range, err_params):
        p_phy_per_partition = np.array([[p_phy * mul for p_phy in sample_range] for mul in err_params.values()]).T
        partitions = {circuit_hash: [partition(circuit, GATE_GROUPS[k]) for k in err_params.keys()]
                      for circuit_hash, circuit in self.protocol._circuits.items() if circuit._noisy}
        w_vecs = {circuit_hash: SubsetSampler.weight_vectors([len(p) for p in pars])
                  for circuit_hash, pars in partitions.items()}
        Aws = {circuit_hash: SubsetSampler.subset_occurence(partitions[circuit_hash], w_vecs, p_phy_per_partition)
               for circuit_hash, w_vecs in w_vecs.items()}
        return partitions, w_vecs, Aws

    def rate(self, sample_range, err_params):
        partitions, w_vecs, Aws = self.setup(sample_range, err_params)
        return self.tree.rate(Aws)

    def var(self, sample_range, err_params):
        partitions, w_vecs, Aws = self.setup(sample_range, err_params)
        return self.tree.var(Aws)

    def delta(self, sample_range, err_params):
        partitions, w_vecs, Aws = self.setup(sample_range, err_params)
        return self.tree.delta(Aws)

    def run(self, n_samples, sample_range, err_params, chi_min=1e-2, p_max=0.1, RSE_target=1e-1, ERV_sel=True, eval_fns={}):

        partitions, w_vecs, Aws = self.setup(sample_range, err_params)
        Aws_at_p_max = {circuit_hash: SubsetSampler.subset_occurence(partitions[circuit_hash], w_vecs, np.array(p_max))
                        for circuit_hash, w_vecs in w_vecs.items()}

        for _ in tqdm(range(n_samples), desc='Total'):

            chi = 1
            sim = self.simulator(self.n_qubits)
            p_it = iterate(self.protocol, eval_fns)
            node = next(p_it)
            tree_node = self.tree.add(name=node)
            tree_node.counts += 1

            while node:

                if not self.protocol.out_edges(node):
                    tree_node.is_fail = True
                    break # terminal node reached

                circuit_hash, circuit = self.protocol.circuit_from_node(node)

                if circuit_hash not in partitions.keys(): # handle circuits created at runtime
                    msmt = sim.run(circuit)
                    Aws[circuit_hash] = np.ones(shape=len(err_params))
                    Aws_at_p_max[circuit_hash] = np.array([1])
                    tree_node = self.tree.add(name=(0,), parent=tree_node, ckey=(circuit_hash, 0),
                                              is_deterministic=circuit._ff_deterministic)
                else:
                    ids = np.where(chi * Aws_at_p_max[circuit_hash] > chi_min)[0]
                    if len(ids) == 0 or not circuit._noisy:
                        idx = 0
                    else:
                        delta = self.tree.delta(Aws_at_p_max)
                        v_L = self.tree.var(Aws_at_p_max)
                        p_L = self.tree.rate(Aws_at_p_max)

                        if not ERV_sel:
                            idx = np.random.choice(ids)
                        else:
                            erv_deltas = []
                            for idx in ids:
                                w_vec = w_vecs[circuit_hash][idx]

                                _tree_node = self.tree.add(w_vec, parent=tree_node, ckey=(circuit_hash, idx))
                                __tree_node = self.tree.add('FAIL', parent=_tree_node, is_fail=True)
                                _delta = self.tree.delta(Aws_at_p_max)
                                _rate = __tree_node.rate

                                _tree_node.counts += 1
                                v_L_minus = self.tree.var(Aws_at_p_max)

                                __tree_node.counts += 1
                                v_L_plus = self.tree.var(Aws_at_p_max)

                                _v_L = _rate * v_L_plus + (1 - _rate) * v_L_minus
                                erv_delta = np.abs(v_L - _v_L) + (delta - _delta)
                                erv_deltas.append( erv_delta )

                                # revert the change
                                _tree_node.counts -= 1
                                __tree_node.counts -= 1
                                if _tree_node.counts == 0: self.tree.detach(_tree_node)
                                if __tree_node.counts == 0: self.tree.detach(__tree_node)

                            idx = np.argmax(erv_deltas)
                            idx = ids[idx]

                    Aw = Aws[circuit_hash][idx]
                    Aw_p_max = Aws_at_p_max[circuit_hash][idx]
                    w_vec = w_vecs[circuit_hash][idx]
                    chi *= Aw_p_max

                    faults = Depolar.faults_from_weights(partitions[circuit_hash], w_vec)
                    fault_circuit = Depolar.gen_circuit(len(circuit), faults)
                    msmt = sim.run(circuit, fault_circuit)

                    tree_node = self.tree.add(name=w_vec, parent=tree_node, ckey=(circuit_hash, idx),
                                              is_deterministic=True if circuit._ff_deterministic and not any(w_vec) else False)

                node = p_it.send(msmt if msmt==None else int(msmt,2)) # exchange with iterator
                if node == None: name = "NO FAIL"
                else: name = node
                tree_node.counts += 1
                tree_node = self.tree.add(name=name, parent=tree_node)
                tree_node.counts += 1

            if p_L > 0 and (np.sqrt(v_L) + delta) / p_L < RSE_target:
                print(f'RSE target of {RSE_target} reached.')
                break

        v_L = self.tree.var(Aws)
        p_L_low = self.tree.rate(Aws)
        p_L_up = p_L_low + self.tree.delta(Aws)

        return p_L_low, p_L_up, np.sqrt(v_L)

    def __str__(self):
        return self.tree.__str__()