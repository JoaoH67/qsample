# AUTOGENERATED! DO NOT EDIT! File to edit: 05b_samplers.protocol_samplers.ipynb (unless otherwise specified).

__all__ = ['ONE_QUBIT_GATES', 'TWO_QUBIT_GATES', 'GATE_GROUPS', 'Sampler', 'SubsetSampler']

# Cell
import qsam.math as math
from ..circuit import partition, make_hash, unpack
from ..fault_generators import Depolar
from ..protocol import iterate
from .sampler_mixins import SubsetAnalytics

import numpy as np
from flexdict import FlexDict
# import itertools as it
# import networkx as nx

# Cell
ONE_QUBIT_GATES = {'H', 'X', 'Z'}
TWO_QUBIT_GATES = {'CNOT'}

GATE_GROUPS = {'p': ONE_QUBIT_GATES | TWO_QUBIT_GATES,
               'p1': ONE_QUBIT_GATES,
               'p2': TWO_QUBIT_GATES,
               }

# Cell
class Sampler:
    def __init__(self, protocol, simulator):
        self.protocol = protocol
        self.simulator = simulator
        self.n_qubits = len(set(q for c in protocol._circuits.values() for q in unpack(c)))

    def run(self, n_samples, sample_range, err_params, var=math.Wilson_var, eval_fns=None):

        fail_cnts = np.zeros(len(sample_range)) # one fail counter per sample point
        partitions = {circuit_hash: [partition(circuit, GATE_GROUPS[k]) for k in err_params.keys()]
                     for circuit_hash, circuit in self.protocol._circuits.items()}

        for i,sample_pt in enumerate(sample_range): # n_samples at sample_pt

            p_phy = np.array(list(err_params.values())) * sample_pt

            for _ in range(n_samples):

                sim = self.simulator(self.n_qubits)
                p_it = iterate(self.protocol, eval_fns)
                node = next(p_it)

                while node:

                    if node == 'EXIT':
                        fail_cnts[i] += 1
                        break
                    else:
                        circuit_hash, circuit = self.protocol.circuit_from_node(node)
                        circuit_partitions = partitions[circuit_hash]
                        faults = Depolar.faults_from_probs(circuit_partitions, p_phy)
                        fault_circuit = Depolar.gen_circuit(len(circuit), faults)
                        msmt = sim.run(circuit, fault_circuit)
                        node = p_it.send(msmt)

        p_L = fail_cnts / n_samples
        std = np.sqrt( var(p_L, n_samples) )
        return p_L, std

# Cell
class SubsetSampler(SubsetAnalytics):
    """Subset Sampler of quantum protocols"""

    def __init__(self, protocol, simulator):
        self.protocol = protocol
        self.simulator = simulator
        self.n_qubits = len(set(q for c in protocol._circuits.values() for q in unpack(c)))

    def run(self, n_samples, sample_range, err_params, chi_min=1e-2, p_max=0.1, var=math.Wilson_var, eval_fns={}):

        p_phy_per_partition = np.array([[p_phy * mul for p_phy in sample_range] for mul in err_params.values()]).T
        partitions = {circuit_hash: [partition(circuit, GATE_GROUPS[k]) for k in err_params.keys()]
                     for circuit_hash, circuit in self.protocol._circuits.items()}

        w_vecs_all = {circuit_hash: SubsetSampler.weight_vectors([len(p) for p in pars])
                      for circuit_hash, pars in partitions.items()}
        Aws_all_at_p_max = {circuit_hash: SubsetSampler.subset_occurence(partitions[circuit_hash], w_vecs, np.array(p_max))
                            for circuit_hash, w_vecs in w_vecs_all.items()}

        counts =  FlexDict()

        for _ in range(n_samples):
            hist = []
            chi = 1

            sim = self.simulator(self.n_qubits)
            p_it = iterate(self.protocol, eval_fns)
            node = next(p_it)

            while True:

                circuit_hash, circuit = self.protocol.circuit_from_node(node)

                # path cutoff
                ids = np.where(chi * Aws_all_at_p_max[circuit_hash] > chi_min)[0]
                idx = 0 if len(ids) == 0 else np.random.choice(ids)
                chi *= Aws_all_at_p_max[circuit_hash][idx]
                w_vec = w_vecs_all[circuit_hash][idx]

                hist.append("%s,%s" % (node,":".join(map(str,w_vec))))
                counts.set(hist + ["N"], 1, increment=True)

                faults = Depolar.faults_from_weights(partitions[circuit_hash], w_vec)
                fault_circuit = Depolar.gen_circuit(len(circuit), faults)
                msmt = sim.run(circuit, fault_circuit)
                node = p_it.send(msmt) # exchange with iterator

                if node == 'EXIT':
                    counts.set(hist + ["EXIT", "N"], 1, increment=True)
                    break
                elif node == None:
                    if not counts.get(hist + ["EXIT", "N"]):
                        counts.set(hist + ["EXIT", "N"], 0)
                    break

        all_paths = []
        for keys,_ in counts.flatten():
            if "EXIT" in keys: # last p_fail for non-fail paths is always 0
                path = []
                for i in range(1,len(keys)-1): # calculate p_fail
                    p = counts[keys[:i+1]]["N"] / counts[keys[:i]]["N"]
                    path.append((keys[i-1], p, counts[keys[:i]]["N"]))
                all_paths.append(path)

        # p_L_low, p_L_up
        delta = 1
        p_L_low = 0
        for path in all_paths:
            prod_acc = 1
            for node_ss, p_fail, _ in path:
                node, w_vec_str = node_ss.split(',')
                c_hash, circuit = self.protocol.circuit_from_node(node)
                w_vec = list(map(int, w_vec_str.split(":")))
                prod_acc *= SubsetSampler.subset_occurence(partitions[c_hash], [w_vec], p_phy_per_partition).flatten()
            p_L_low += prod_acc * np.prod([p for _,p,_ in path[:]])
            delta -= prod_acc * (1 if len(path) < 2 else np.prod([p for _,p,_ in path[:-1]]))
        p_L_up = p_L_low + delta

        # v_L
#         v_L = 0
#         for path in all_paths:
#             if np.sum([tuple(map(int,node_ss.split(',')[1].split(':'))) for node_ss,_,_ in path]) != 0:
#                 for node_ss_i, p_fail_i, n_i in path:
#                     node, w_vec_str = node_ss_i.split(',')
#                     c_hash, circuit = self.protocol.circuit_from_node(node)
#                     w_vec = tuple(map(int, w_vec_str.split(":")))
#                     Aw_i = SubsetSampler.subset_occurence(partitions[c_hash], [w_vec], p_phy_per_partition).flatten()
#                     prod_acc = 1
#                     for node_ss_j, p_fail_j, _ in path:
#                         if node_ss_j != node_ss_i:
#                             node, w_vec_str = node_ss_j.split(',')
#                             c_hash, circuit = self.protocol.circuit_from_node(node)
#                             w_vec = tuple(map(int, w_vec_str.split(":")))
#                             Aw_j = SubsetSampler.subset_occurence(partitions[c_hash], [w_vec], p_phy_per_partition).flatten()
#                             prod_acc *= Aw_j * p_fail_j

#                     v_fail_i = var(p_fail_i, n_i)
#                     v_L += v_fail_i * Aw_i ** 2 * prod_acc ** 2


        v_L = 0
        for path in all_paths:
            if np.sum([tuple(map(int,node_ss.split(',')[1].split(':'))) for node_ss,_,_ in path]) != 0:
                for node_ss_i, p_fail_i, n_i in path:
                    node, w_vec_str = node_ss_i.split(',')
                    c_hash, circuit = self.protocol.circuit_from_node(node)
                    w_vec = tuple(map(int, w_vec_str.split(":")))
                    Aw_i = SubsetSampler.subset_occurence(partitions[c_hash], [w_vec], p_phy_per_partition).flatten()
                    v_fail_i = var(p_fail_i, n_i)

                    sum_acc = np.zeros_like(Aw_i)
                    for pathB in all_paths:
                        if np.sum([tuple(map(int,node_ss.split(',')[1].split(':'))) for node_ss,_,_ in pathB]) != 0:
                            prod_acc = 1
                            for node_ss_j, p_fail_j, _ in pathB:
                                if node_ss_j != node_ss_i:
                                    node, w_vec_str = node_ss_j.split(',')
                                    c_hash, circuit = self.protocol.circuit_from_node(node)
                                    w_vec = tuple(map(int, w_vec_str.split(":")))
                                    Aw_j = SubsetSampler.subset_occurence(partitions[c_hash], [w_vec], p_phy_per_partition).flatten()
                                    prod_acc *= Aw_j * p_fail_j
                            sum_acc += prod_acc
                    sum_acc = 1 if sum_acc.any() == 0 else sum_acc

                    v_L += v_fail_i * Aw_i ** 2 * sum_acc ** 2

        return p_L_low, p_L_up, np.sqrt(v_L)