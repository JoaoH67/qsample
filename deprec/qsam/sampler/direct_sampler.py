# AUTOGENERATED! DO NOT EDIT! File to edit: 03b_sampler.direct_sampler.ipynb (unless otherwise specified).

__all__ = ['DirectSampler']

# Cell
import qsam.math as math
from ..callbacks import CallbackList
from .base_sampler import BaseSampler

import numpy as np
from tqdm.auto import tqdm # automatically choose jupyter tqdm version when available.

# Cell

class DirectSampler(BaseSampler):

    def setup(self):
        n_p_phy = len(self.fault_gen.p_phy)
        self.cnts = np.zeros( n_p_phy )
        self.fail_cnts = np.zeros( n_p_phy )

    def stats(self, p_idx=..., var_fn=math.Wilson_var):
        rate = self.fail_cnts[p_idx] / self.cnts[p_idx]
        var = var_fn(rate, self.cnts[p_idx])
        return rate, np.sqrt(var)

    def loop_fn(self, kwargs):
        circuit_hash = kwargs["circuit_hash"]
        p_phy = kwargs["p_phy"]
        w_vec, faults = self.fault_gen.faults_from_probs(p_phy, circuit_hash)
        w_idx = self.w_vecs[circuit_hash].index(w_vec)
        return {'w_vec': w_vec, 'w_idx': w_idx, 'faults': faults}

    def run(self, n_samples, callbacks=[]):

        if not isinstance(callbacks, CallbackList):
            callbacks = CallbackList(sampler=self, callbacks=callbacks)
        callbacks.on_sampler_begin()

        for i, p_phy in enumerate(tqdm(self.fault_gen.p_phy, desc='Total')):
            self.stop_sampling = False
            self.p_idx = i

            for _ in tqdm(range(n_samples), desc=f'p_phy={",".join(list(f"{p:.2E}" for p in p_phy))}', leave=True):
                self.cnts[i] += 1
                self.fail_cnts[i] += self.sample(callbacks, p_phy=p_phy)
                if self.stop_sampling: break

        callbacks.on_sampler_end()