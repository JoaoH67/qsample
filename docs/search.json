[
  {
    "objectID": "protocol.html",
    "href": "protocol.html",
    "title": "Protocol",
    "section": "",
    "text": "draw_protocol\n\n draw_protocol (protocol, path=None, legend=False, figsize=(6, 6),\n                label_offset=(0.05, 0.05))\n\nDraw protocol using networkx library\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nprotocol\nProtocol\n\nThe protocol to draw\n\n\npath\nNoneType\nNone\nThe path to save the resulting image to (optional)\n\n\nlegend\nbool\nFalse\nIf true, edge labels will be numbers referenced in legend\n\n\nfigsize\ntuple\n(6, 6)\nThe matplotlib figsize argument of the plot\n\n\nlabel_offset\ntuple\n(0.05, 0.05)\nOffset position of all edge labels\n\n\n\n/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Attributes\n  else: warn(msg)\n\n\n\nProtocol\n\n Protocol (ft_level=0, check_functions={}, *args, **kwargs)\n\nRepresentation of a Quantum (Error Correction) Protocol\n\nfrom qsample.examples import ghz1\nassert(ghz1.successor('START', {})[0] == 'ghz')\nassert(ghz1.successor('ghz', {'ghz': [1]})[0] == 'FAIL')\nghz1.successor('ghz', {'ghz': [1]})\n\n('FAIL', None)\n\n\n\n\n\n\nfrom qsample.examples import ghz3\nassert(ghz3.successor('START', {})[0] == 'ghz')\nassert(ghz3.successor('ghz', {'ghz': [1]})[0] == 'ghz')\nassert(ghz3.successor('ghz', {'ghz': [1,1,1]})[0] == 'FAIL')"
  },
  {
    "objectID": "sampler.tree.html",
    "href": "sampler.tree.html",
    "title": "Count Tree",
    "section": "",
    "text": "This data structure is based on the Python package anytree (https://github.com/c0fec0de/anytree) which has been extended by the classes SubsetCountNode, CircuitCountNode and CountTree.\n\n\ndraw_tree\n\n draw_tree (tree, path=None)\n\nGenerate and return PNG image of CountTree\nTo display the image in command line call .show() on the returned PIL image object.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntree\n\n\n\n\n\npath\nNoneType\nNone\nFile path to save png image to, if None only display image\n\n\nReturns\nPNG image\n\nImage of CountTree\n\n\n\n\n\n\nCircuitCountNode\n\n CircuitCountNode (name, count=0, invariant=False, parent=None,\n                   children=None)\n\nSubclass of Node to represent a circuit node.\nCircuitCountNode represent differentiable rates in a CountTree. Differentiability refers to the partial derivatives in the propagation of uncertainty formula for the lower and upper bound of the logical failure rate.\n/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Attributes\n  else: warn(msg)\n\n\n\nSubsetCountNode\n\n SubsetCountNode (name, circuit_id=None, invariant=False, count=0,\n                  parent=None, children=None)\n\nSubclass of CountNode to represent a subset node\n\n\n\nCountNode\n\n CountNode (name, count=0, invariant=False, parent=None, children=None)\n\nClass to represent a tree node of a CountTree.\nA node in a tree is a uniquely identifiable object containing references to at most one parent and possibly many children. The root node has no parent and leaf nodes have not children.\nThe CountNode class complements the common tree node by a count attribute which represents the number of times a node has been visited during sampling.\n\n\n\nCountTree\n\n CountTree (constants)\n\nClass to represent a tree of CircuitCountNode and SubsetCountNode nodes.\nTest creating a 1-level tree.\n\n# Test 1-level tree\n\nconstants = {0: {(0,): 0.8, (1,): 0.1, (2,): 0.05}}\ntree = CountTree(constants)\nroot = tree.add(name='root', node_type=CircuitCountNode, count=100)\nroot0 = tree.add(name=(0,), circuit_id=0, node_type=SubsetCountNode, parent=root, count=40)\nroot1 = tree.add(name=(1,), circuit_id=0, node_type=SubsetCountNode, parent=root, count=30)\nroot2 = tree.add(name=(2,), circuit_id=0, node_type=SubsetCountNode, parent=root, count=30)\nnone_0 = tree.add(name='None', node_type=CircuitCountNode, parent=root0, count=40)\nnone_0.invariant = True\nfail_1 = tree.add(name='fail', node_type=CircuitCountNode, parent=root1, count=20)\nnone_1 = tree.add(name='None', node_type=CircuitCountNode, parent=root1, count=10)\nfail_2 = tree.add(name='fail', node_type=CircuitCountNode, parent=root2, count=5)\nnone_2 = tree.add(name='None', node_type=CircuitCountNode, parent=root2, count=25)\n\ntree.marked_leaves = set([fail_1, fail_2])\nprint(tree)\n\nroot (100, 0.00e+00)\n├── (0,) (40)\n│   └── None (40, 0.00e+00)\n├── (1,) (30)\n│   ├── fail (20, 7.20e-03)\n│   └── None (10, 7.20e-03)\n└── (2,) (30)\n    ├── fail (5, 4.60e-03)\n    └── None (25, 4.60e-03)\n\n\nTest numerics of 1-level tree.\n\n# Test numerics 1-level tree\n\ntest_eq(tree.root_leaf_rate, 20/100 + 5/100)\ntest_eq(tree.path_sum(tree.root, mode=1), 0.1 * 20/30 + 0.05 * 5/30)\ntest_close(tree.path_sum(tree.root, mode=2), 0.8 + 0.1 + 0.05, eps=1e-05)\ntest_close(tree.uncertainty_propagated_variance(mode=1), 0.1**2 * fail_1.variance + 0.05**2 * fail_2.variance, eps=1e-05)\ntest_close(tree.uncertainty_propagated_variance(mode=0), 0.1**2 * none_1.variance + 0.05**2 * none_2.variance, eps=1e-05)\n\nTest creation of 2-level tree.\n\n# Test 2-level tree\n\nconstants = {0: {(0,): 0.8, (1,): 0.1}, \n             1: {(0,): 0.7, (1,): 0.2},\n             2: {(0,): 1.0}}\n\ntree = CountTree(constants)\nroot = tree.add(name='c0', node_type=CircuitCountNode, count=100)\nroot0 = tree.add(name=(0,), circuit_id=0, node_type=SubsetCountNode, parent=root, count=70)\nroot1 = tree.add(name=(1,), circuit_id=0, node_type=SubsetCountNode, parent=root, count=30)\nc1_0 = tree.add(name='c1', node_type=CircuitCountNode, count=50, parent=root0)\nc1_0.invariant = True\nc1_1 = tree.add(name='c1', node_type=CircuitCountNode, count=20, parent=root1)\nc2_0 = tree.add(name='c2', node_type=CircuitCountNode, count=20, parent=root0)\nc2_0.invariant = True\nc2_1 = tree.add(name='c2', node_type=CircuitCountNode, count=10, parent=root1)\n\nc1_0_0 = tree.add(name=(0,), circuit_id=1, node_type=SubsetCountNode, parent=c1_0, count=40)\nc1_0_1 = tree.add(name=(1,), circuit_id=1, node_type=SubsetCountNode, parent=c1_0, count=10)\nc1_1_0 = tree.add(name=(0,), circuit_id=1, node_type=SubsetCountNode, parent=c1_1, count=15)\nc1_1_1 = tree.add(name=(1,), circuit_id=1, node_type=SubsetCountNode, parent=c1_1, count=5)\n\nc2_0_0 = tree.add(name=(0,), circuit_id=2, node_type=SubsetCountNode, parent=c2_0, count=20)\nc2_1_0 = tree.add(name=(0,), circuit_id=2, node_type=SubsetCountNode, parent=c2_1, count=10)\n\nnone_c1_0_0 = tree.add(name='None', node_type=CircuitCountNode, parent=c1_0_0, count=40)\nnone_c1_0_0.invariant = True\nnone_c1_0_1 = tree.add(name='None', node_type=CircuitCountNode, parent=c1_0_1, count=5)\nfail_c1_0_1 = tree.add(name='fail', node_type=CircuitCountNode, parent=c1_0_1, count=5)\nnone_c1_1_0 = tree.add(name='None', node_type=CircuitCountNode, parent=c1_1_0, count=15)\nnone_c1_1_1 = tree.add(name='None', node_type=CircuitCountNode, parent=c1_1_1, count=3)\nfail_c1_1_1 = tree.add(name='fail', node_type=CircuitCountNode, parent=c1_1_1, count=2)\n\nnone_c2_0_0 = tree.add(name='None', node_type=CircuitCountNode, parent=c2_0_0, count=20)\nnone_c2_0_0.invariant = True\nfail_c2_1_0 = tree.add(name='fail', node_type=CircuitCountNode, parent=c2_1_0, count=10)\n\ntree.marked_leaves = set([fail_c1_0_1, fail_c1_1_1, fail_c2_1_0])\nprint(tree)\n\nc0 (100, 0.00e+00)\n├── (0,) (70)\n│   ├── c1 (50, 0.00e+00)\n│   │   ├── (0,) (40)\n│   │   │   └── None (40, 0.00e+00)\n│   │   └── (1,) (10)\n│   │       ├── None (5, 2.27e-02)\n│   │       └── fail (5, 2.27e-02)\n│   └── c2 (20, 0.00e+00)\n│       └── (0,) (20)\n│           └── None (20, 0.00e+00)\n└── (1,) (30)\n    ├── c1 (20, 7.20e-03)\n    │   ├── (0,) (15)\n    │   │   └── None (15, 9.77e-04)\n    │   └── (1,) (5)\n    │       ├── None (3, 4.03e-02)\n    │       └── fail (2, 4.03e-02)\n    └── c2 (10, 7.20e-03)\n        └── (0,) (10)\n            └── fail (10, 2.07e-03)\n\n\nTest numerics of 2-level tree.\n\n# Test numerics 2-level tree\n\ntest_eq(tree.root_leaf_rate, 5/100 + 2/100 + 10/100)\ntest_eq(tree.path_sum(tree.root, mode=1), 0.8 * 50/70 * 0.2 * 5/10 + 0.1 * (20/30 * 0.2 * 2/5 + 10/30 * 1.0 * 1))\ntest_close(tree.path_sum(tree.root, mode=2), 0.8 * (50/70 * 0.9 + 20/70) + 0.1 * (20/30 * 0.9 + 10/30), eps=1e-05)\nvar1 = (0.8 * 0.2 * 5/10)**2 * c1_0.variance + (0.8 * 50/70 * 0.2)**2 * fail_c1_0_1.variance + (0.1 * 0.2 * 2/5 - 0.1 * 1)**2 * c1_1.variance + (0.1 * 0.2 * 20/30)**2 * fail_c1_1_1.variance\ntest_close(tree.uncertainty_propagated_variance(mode=1), var1, eps=1e-05)\nvar2 = (0.8 * (0.7 * 1 + 0.2 * 5/10 - 1))**2 * c1_0.variance + (0.8 * 50/70 * 0.2)**2 * fail_c1_0_1.variance + (0.1 * (0.7 + 0.2*3/5))**2 * c1_1.variance + (0.1 * 20/30 * 0.2)**2 * fail_c1_1_1.variance\ntest_close(tree.uncertainty_propagated_variance(mode=0), var2, eps=1e-05)"
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "ghz.draw()\n\n\n\n\n\nghz_stabs.draw(scale=1.2)\n\n\n\n\n\neft.draw(scale=1.5)\n\n\n\n\n\nsz_123.draw()\n\n\n\n\n\nmeas7.draw(scale=1.2)\n\n\n\n\n\nnfs.draw(scale=1)"
  },
  {
    "objectID": "examples.html#ghz-repeat-until-success-protocol",
    "href": "examples.html#ghz-repeat-until-success-protocol",
    "title": "Examples",
    "section": "GHZ repeat until success protocol",
    "text": "GHZ repeat until success protocol\n\nRepeat GHZ preparation circuit for a maximum of 3 times.\nOnly repeat if a measurement yields 1, i.e. the flag has been triggered.\nIf we measure in all 3 runs three times 1, count a logical failure.\nIn all other cases the protocol completed without logical failure.\n\n\nghz3.draw(figsize=(6,6))"
  },
  {
    "objectID": "examples.html#ghz-stabilizer-measurement",
    "href": "examples.html#ghz-stabilizer-measurement",
    "title": "Examples",
    "section": "GHZ stabilizer measurement",
    "text": "GHZ stabilizer measurement\n\nPrepare GHZ state with flag measurement 0. (If 1 is measured repeat preparation as often as necessary)\nReset ancilla and measure the stabilizers of the GHZ state (without noise). The stabilizers are:\n\nOne XXXX stab\nand three ZZ stabs\n\nUse syndrom from stabilizer measurements to lookup and perform the correction.\nMeasure stabilizers again.\nNow we have a logical failure if this measurement gives us any syndrome, i.e. if the measurement is anything other than four 0s.\n\n\nghz_stab.draw(figsize=(6,6), legend=True)"
  },
  {
    "objectID": "examples.html#fault-tolerant-color-code-flag-protocol",
    "href": "examples.html#fault-tolerant-color-code-flag-protocol",
    "title": "Examples",
    "section": "Fault-tolerant color code flag protocol",
    "text": "Fault-tolerant color code flag protocol\n\n…\n\n\nftsteane.draw(figsize=(8,6), label_offset=(0,0.15))"
  },
  {
    "objectID": "examples.html#det.-steane-logical-0-preparation-protocol",
    "href": "examples.html#det.-steane-logical-0-preparation-protocol",
    "title": "Examples",
    "section": "Det. Steane logical 0 preparation protocol",
    "text": "Det. Steane logical 0 preparation protocol\n\nsteane0.draw(figsize=(6,6), legend=True)"
  },
  {
    "objectID": "examples.html#flag-stabilizer-protocol",
    "href": "examples.html#flag-stabilizer-protocol",
    "title": "Examples",
    "section": "Flag stabilizer protocol",
    "text": "Flag stabilizer protocol\n\n…\n\n\nflagstab.draw(legend=True, figsize=(15,5))"
  },
  {
    "objectID": "noise.html",
    "href": "noise.html",
    "title": "Error models",
    "section": "",
    "text": "Some common error sets\n\n\nErrorModel\n\n ErrorModel ()\n\nRepresentation of an incoherent error model.\n\n\n\nE0\n\n E0 ()\n\nNo-Error error model\n\n\n\nE1\n\n E1 ()\n\nOne prob/weight for all 1- and 2-qubit gates\n\n\n\nE2\n\n E2 ()\n\nIndividual errors on 1-qubit and 2-qubit gates.\n\n\n\nE3\n\n E3 ()\n\nErrors on all gates individual + idle.\n\n\n\nE3_1\n\n E3_1 ()\n\nLike E3, but idle locations split in two subsets.\n\n\n\nInnsbruckTrap\n\n InnsbruckTrap ()\n\nExtension of E3_1 adding crosstalk and idlem."
  },
  {
    "objectID": "math.html",
    "href": "math.html",
    "title": "Math",
    "section": "",
    "text": "comb\n\n comb (n, k)\n\nVectorized combination\n.. math:: comb(n,k) = n! / ((n-k)!k!)\n\n\n\n\nType\nDetails\n\n\n\n\nn\nint or np.array of int\nFirst parameter of combination\n\n\nk\nint or np.array of int\nSecond parameter of combination\n\n\nReturns\nnp.array\nCombination (choose k out of n)\n\n\n\n/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Example\n  else: warn(msg)\n\n\n\nbinom\n\n binom (k, n, p)\n\nVectorized binomial distribution\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nk\nint or list of int\nSecond parameter of combination\n\n\nn\nint or list of int\nFirst parameter of combination\n\n\np\nfloat or list of float\nProbability\n\n\nReturns\nnp.array\nValue(s) of binomial distribution evaluated at k,n,p.\n\n\n\n\ntest_close(binom(k=[1,2], n=[3,4], p=0.1), [0.243 , 0.0486], eps=1e-05)\n\n\n\n\njoint_binom\n\n joint_binom (k, n, p)\n\nProduct of independent binomial distributions with parameters k, n and same p.\n\n\n\n\nType\nDetails\n\n\n\n\nk\nlist of int\nList of second parameters of combination\n\n\nn\nlist of int\nList of first parameters of combination\n\n\np\nfloat list of float\nProbability\n\n\nReturns\nnp.array\nJoint probability\n\n\n\n\nassert(joint_binom(k=[1,2], n=[3,4], p=[0.1,0.2]) == binom(k=1,n=3,p=0.1) * binom(k=2,n=4,p=0.2))\ntest_close(joint_binom(k=[1,2], n=[2,3], p=[[0.1,0.2],[.3,.4]]), [binom(1,2,0.1)*binom(2,3,0.2), binom(1,2,0.3)*binom(2,3,0.4)])\n\n\n\n\nWilson_var\n\n Wilson_var (p, N)\n\nWilson estimator of binomial variance\nThe formula for the Wilson interval is:\n.. math:: CI = p+z^2/(2n) z/(1 + z^2/n)\nwhich we assume symmetric, s.t. we can extract the std (z=1), thus:\n.. math: Var[p] = (CI/2)^2 = (npq + 0.25) / (1 + n)^2\n\n\n\n\nType\nDetails\n\n\n\n\np\nfloat\nEstimator of probability\n\n\nN\nint\nSample size\n\n\nReturns\nfloat\nEstimated variance of Wilson CI\n\n\n\n\n\n\nWald_var\n\n Wald_var (p, N)\n\nWald estimation of binomial variance\n\n\n\n\nType\nDetails\n\n\n\n\np\nfloat\nEstimator of probability\n\n\nN\nint\nSample size\n\n\nReturns\nfloat\nEstimated variance of Wald CI\n\n\n\n\n\n\nsubset_cards\n\n subset_cards (superset)\n\nCalculate cardinalities of all possible subsets of superset\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nsuperset\nset\nInput set\n\n\nReturns\nlist of int\nAll possible cardinalities of subsets\n\n\n\n\nassert(subset_cards({1,2,3}) == {0,1,2,3})\nassert(subset_cards({(0,0), (0,1), (0,2)}) == {0,1,2,3})\n\n\n\n\ncartesian_product\n\n cartesian_product (list_of_sets)\n\nCalculate cartesian product between all members of sets\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nlist_of_sets\nlist\nList of sets between which to calculate Cartesian product\n\n\nReturns\nlist of tuple\nCartesian products\n\n\n\n\nassert(cartesian_product([{1,2},{3,4}]) == [(1,3), (1,4), (2,3), (2,4)])"
  },
  {
    "objectID": "circuit.html",
    "href": "circuit.html",
    "title": "Circuit",
    "section": "",
    "text": "unpack\n\n unpack (seq)\n\nGenerator to unpack all values of dicts inside a list of dicts\n\n\n\n\nType\nDetails\n\n\n\n\nseq\nIterable\nIterable to recursively unpack\n\n\n\n\n\n\ndraw_circuit\n\n draw_circuit (circuit, path=None, scale=2)\n\nDraw circuit using latextools library\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncircuit\nCircuit\n\nThe circuit to draw\n\n\npath\nNoneType\nNone\nThe path to save the resulting image to (optional)\n\n\nscale\nint\n2\nThe scale of the image\n\n\nReturns\ndrawSvg.drawing.Drawing\n\nImage object\n\n\n\n/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Attributes\n  else: warn(msg)\n\n\n\nCircuit\n\n Circuit (ticks=None, noisy=True, ff_det=False)\n\nRepresentation of a quantum circuit\n\nlist(unpack([{'X': {1,2,3}},{'CNOT': {(0,1), (1,3)}}]))\n\n[1, 2, 3, 0, 1, 1, 3]\n\n\n\n# Tests\n\nc1 = Circuit(ticks=[{'Z': {0}}])\nc2 = Circuit(ticks=[{'X': {3}}])\nc3 = Circuit(ticks=[{'X': {3}}, {'Z': {0}}])\nc4 = Circuit(ticks=[])\nassert(c1.id != c2.id != c3.id != c4.id)\nc1.id, c2.id, c3.id, c4.id\n\n('bceb2', '04f89', 'b597e', 'da39a')\n\n\n\n# c = Circuit(ticks=[{'init': {0,1,2,3}}, {'X': {0,1}}, {'CNOT': {(0,3)}}, {'measure': {1,3}}])\n# c.partition\n\n\nc = Circuit()\nc.insert(tick_index=0, tick={'Z': {0}})\nc\n\n0: {'Z': {0}}"
  },
  {
    "objectID": "sim.mixin.html",
    "href": "sim.mixin.html",
    "title": "Simulator Mixin",
    "section": "",
    "text": "CircuitRunnerMixin\n\n CircuitRunnerMixin ()\n\nSimulator mixin for running quantum circuits"
  },
  {
    "objectID": "sampler.direct.html",
    "href": "sampler.direct.html",
    "title": "Direct Sampler",
    "section": "",
    "text": "from qsample.examples import ghz3\nfrom qsample.noise import E1, E2\nfrom qsample.sim.stabilizer import StabilizerSimulator as CHP\nfrom qsample.callbacks import *\n\n\ne = E1\n\nsample_range = np.logspace(-3,0,5)\n\nerr_probs = {\n    \"q\": sample_range,\n}\n\nsam = DirectSampler(ghz3, CHP, err_params=err_probs, err_model=e)\n\nsam.run(1000, callbacks=[PlotStats()])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ne = E2\n\nsample_range = np.logspace(-3,0,5)\n\nerr_params = {\n    \"q2\": sample_range,\n    \"q1\": 0.01\n}\n\nsam = DirectSampler(ghz3, CHP, err_params=err_params, err_model=e)\n\nsam.run(1000, callbacks=[PlotStats()])"
  },
  {
    "objectID": "callbacks.html",
    "href": "callbacks.html",
    "title": "Sampler Callbacks",
    "section": "",
    "text": "/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Attributes\n  else: warn(msg)\n\n\nCallbackList\n\n CallbackList (sampler, callbacks=[])\n\nManages execution of all specified callbacks\n\n\n\nCallback\n\n Callback ()\n\nCallback super class: All callbacks must inherit this class.\n\n\n\nPlotStats\n\n PlotStats ()\n\nPlot sampler statistics at end of sampling process\n\n\n\nRelStdTarget\n\n RelStdTarget (target=0.1, include_delta=True)\n\nCallback to stop sampling when the relative standard deviation target target is reached\n\n\n\nStatsPerShot\n\n StatsPerShot (log_dir=None)\n\nStore information of Sampler.stats() with each shot and plot each statistic as as function of shots after sampler ends\n\n\n\nVerboseCircuitExec\n\n VerboseCircuitExec ()\n\nCallback to output detailed information about circuit selection, specific fault that occured, measurement outcome and next circuit\n\n\n\nErvPerSample\n\n ErvPerSample (log_dir=None)\n\nCallback to plot statistics about ERV values and selected subsets due to ERV\n\n\n\nPathProducts\n\n PathProducts (log_dir=None)\n\nCallback to plot distribution of sampled paths\n\n\n\nSubsetRates\n\n SubsetRates (log_dir=None)\n\nCallback to plot progression of each fail path as a function of shots"
  },
  {
    "objectID": "sim.stabilizer.html",
    "href": "sim.stabilizer.html",
    "title": "CHP Simulator",
    "section": "",
    "text": "/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Reference\n  else: warn(msg)\n\n\nStabilizerSimulator\n\n StabilizerSimulator (num_qubits)\n\nThe bare minimum needed for the CHP simulation."
  },
  {
    "objectID": "sim.statevector.html",
    "href": "sim.statevector.html",
    "title": "Statevector Simulator",
    "section": "",
    "text": "/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Attributes\n  else: warn(msg)\n\n\nMeasureResult\n\n MeasureResult (value:bool)\n\nClass to hold measurement result\n\n\n\nStatevectorSimulator\n\n StatevectorSimulator (num_qubits)\n\nStatevector simulator using ProjectQ simulator"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "qsample",
    "section": "",
    "text": "pip install qsample"
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "qsample",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nThis package requires Python 3.9 or higher.\n\npdflatex (for circuit rendering)"
  },
  {
    "objectID": "index.html#when-to-use",
    "href": "index.html#when-to-use",
    "title": "qsample",
    "section": "When to use",
    "text": "When to use\nThis package is for you if you want to\n* model circuit-level incoherent Pauli noise (we don’t do coherent noise here, neither are our auxiliary qubits modelled as ideal)\n* with high fidelity physical operations aka low physical error rates\n* for a QEC protocol that consists of execution of one or more quantum circuits with in-sequence measurements and feed-forward of measurement information\n* over a specific range of varying physical error rates"
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "qsample",
    "section": "Getting started",
    "text": "Getting started\n\n\nLibrary overview\n\nCircuit\nProtocol\nError Model\nSimulator\nSampler\n5.1. Direct Sampler\n5.2. Interlude: Callbacks\n5.3. Subset Sampler\n\n\n\n1. Circuit\n\nList of ticks\nEach tick is a dictionary, key: gate type, value: set of qubit(s)\nRecommended: 1 gate type per tick\n\nExample: Flagged-GHZ preparation: * Produce GHZ state on qubits 0-3\n* Flag-qubit 4, measure:\n* 0: error-free*\n* 1: flip on one data qubit*\n* Only for max. 1 allowed fault.\n\nfrom qsample import Circuit\n\n\nghz = Circuit([ {\"init\": {0,1,2,3,4}},\n                {\"H\": {0}},\n                {\"CNOT\": {(0,1)}},\n                {\"CNOT\": {(1,2)}},\n                {\"CNOT\": {(2,3)}},\n                {\"CNOT\": {(3,4)}},\n                {\"CNOT\": {(0,4)}},\n                {\"measure\": {4}}], ff_det=True)\n\nff_det: fault-free deterministic. Set to True if circuit gives unique measurement result when executed without faults.\n\nghz.draw()\n\n\n\n\n\n\n2. Protocol\n\nGraph (can be cyclic)\n\nVertices: Circuits\nEdges: transition rules = boolean* functions (checks)\nMust include start and end nodes.\n\n\n* Exception: Correction functions can return circuits for on-the-fly execution. (special case, will not show here)\nExample: Flagged-GHZ repeat(3)-until-success\n* Execute flagged-GHZ circuit max. 3 times.\n* Only repeat if measured 1.\n* If measured flag to be 0 within 3 iteration -> No fail\n* If after 2 iterations 3rd measurement is also 1 -> Fail\n\nfrom qsample import Protocol\n\n\nghz3 = Protocol(fault_tolerant=True)\n\nghz3.add_node('ghz', circuit=ghz) # Add node with corresponding circuit\nghz3.add_edge('START', 'ghz', check='True') # Transition START -> first circuit node always True\nghz3.add_edge('ghz', 'ghz', check='repeat(ghz)') # Transition to ghz if repeat(ghz) True.\nghz3.add_edge('ghz', 'FAIL', check='logErr(ghz)') # Transition to final node FAIL if logErr(ghz) True.\n\nfault_tolerant: Define all weight-1 paths (circuit sequence with max. 1 fault) to never result in a logical fail.\n\nghz3.draw()\n\n\n\n\n\nrepeat() and logErr() are user-defined (boolean) check functions\n\nMeasurement history of circuits stored during for protocol run\n\nCan access measurement history of any circuit by passing its name as argument\n\n\nNext, we define what the two check functions should do:\n\ndef repeat(msmt_list): # arg: list of ghz's measurment history\n    return len(msmt_list) < 3 and msmt_list[-1] == 1 # If True repeat ghz\n\ndef logErr(msmt_list):\n    return len(msmt_list) == 3 and msmt_list[-1] == 1 # If True transition to `FAIL`\n\nfunctions = {'logErr': logErr, 'repeat': repeat}\nghz3._check_fns.update(functions) # Let protocol know about user-defined checks\n\nNote: It is also possible that all checks are false. In this case the protocol exits “insignficantly”.\nHere: “insignificant” when Flag=0 within 3 protocol runs -> Go to next protocol run, i.e. sample.\n\n\n3. Error model\n\nStrategy:\n\nGenerate fault circuit \\(C_f\\) of same length as reference circuit \\(C\\)\n\nDuring simulation iterate \\(C\\) and \\(C_f\\) simulateously and apply to state\n\n\nMust include:\n\ngroup(): group circuit locations by key, e.g. all 1-qubit-gates\n\nselect(): picks certain amount of locations from each group (not required by user)\n\ngenerate(): generator function, returns a Pauli fault operator for given location\n\n\n\nfrom qsample.noise import E1\n\nE1.groups, E1().group(ghz) # All gates in group `q`\n\n(['q'],\n {'q': [(1, 0),\n   (2, (0, 1)),\n   (3, (1, 2)),\n   (4, (2, 3)),\n   (5, (3, 4)),\n   (6, (0, 4))]})\n\n\n\n\n4. Simulator\n\nTwo types available: Stabilizer (CHP) and Statevectors (ProjectQ port), both well-tested\n\nhttps://github.com/Strilanc/python-chp-stabilizer-simulator\nhttps://github.com/ProjectQ-Framework/ProjectQ\n\nStatevector simulator has more available gates and functions\n\n\nfrom qsample import StabilizerSimulator as CHP\n\n\n\n5. Sampler\n\nTwo types: Direct (Monte Carlo) and Subset sampler\nAll relevant information stored in CountTree data structure\n\n\n\n5.1. Direct sampler\n\nfrom qsample import DirectSampler\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nLet’s define some physical error rates at which to sample:\n\nsample_range = np.logspace(-3,0,5)\nerr_probs = {'q': sample_range} # Note: Must provide rate(s) for each group specified in `ErrorModel`\nerr_probs\n\n{'q': array([0.001     , 0.00562341, 0.03162278, 0.17782794, 1.        ])}\n\n\n\ndsam = DirectSampler(protocol=ghz3, simulator=CHP, err_probs=err_probs, err_model=E1)\ndsam.run(10000)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np_L, std = dsam.stats()\n\nplt.errorbar(sample_range, p_L, fmt='--', c=\"black\", yerr=std, label=\"Direct MC\")\nplt.plot(sample_range, sample_range,'k:', alpha=0.5)\nplt.xscale('log')\nplt.yscale('log')\nplt.xlabel('$p_{phy}$(q)')\nplt.ylabel('$p_L$');\n\n\n\n\nCheck what has been sampled for the last (1e0) physical error rate:\n\ndsam.trees[(1.0,)].draw()\n\n\n\n\n\n\n5.2. Interlude: Callbacks\n\nUsed to receive intermediate results inside sampling process\nE.g. we might want to avoid unnecessary samples (at large \\(p_{phy}\\))\n\nWe can use the callback RelStdTarget\n\n\n\nfrom qsample import callbacks as cb\n\ndsam2 = DirectSampler(protocol=ghz3, simulator=CHP, err_probs=err_probs, err_model=E1)\ndsam2.run(10000, callbacks=[cb.RelStdTarget(target=0.2)])\n\n\n\n\n\n\n\n\n\n\n\n\n\nRel. std target of 0.2 reached. Sampling stopped.\n\n\n\n\n\nRel. std target of 0.2 reached. Sampling stopped.\n\n\nAnother callback is VerboseCircuitExec, which gives a detailed log of which circuits, faults and measurements took place:\n\ndsam3 = DirectSampler(protocol=ghz3, simulator=CHP, err_probs={'q': 0.1}, err_model=E1)\ndsam3.run(10, callbacks=[cb.VerboseCircuitExec()])\n\n\n\n\nghz -> Faults: [] -> Msmt: 0\nNone\nghz -> Faults: [(3, {'X': {1, 2}})] -> Msmt: 1\nghz -> Faults: [(2, {'Z': {0}, 'Y': {1}})] -> Msmt: 1\nghz -> Faults: [] -> Msmt: 0\nNone\nghz -> Faults: [] -> Msmt: 0\nNone\nghz -> Faults: [(2, {'Z': {1}}), (6, {'Y': {0}})] -> Msmt: 0\nNone\nghz -> Faults: [] -> Msmt: 0\nNone\nghz -> Faults: [(3, {'Z': {1}, 'Y': {2}}), (5, {'Z': {4}})] -> Msmt: 1\nghz -> Faults: [(2, {'Z': {0}, 'X': {1}})] -> Msmt: 1\nghz -> Faults: [(5, {'Y': {3, 4}})] -> Msmt: 1\nFAIL\nghz -> Faults: [(4, {'X': {3}}), (6, {'X': {0}})] -> Msmt: 1\nghz -> Faults: [] -> Msmt: 0\nNone\nghz -> Faults: [] -> Msmt: 0\nNone\nghz -> Faults: [] -> Msmt: 0\nNone\nghz -> Faults: [(3, {'X': {1}, 'Z': {2}}), (4, {'X': {2, 3}})] -> Msmt: 1\nghz -> Faults: [(3, {'Y': {1, 2}})] -> Msmt: 1\nghz -> Faults: [(6, {'X': {4}})] -> Msmt: 1\nFAIL\n\n\nWe can also write our own callback. Every sampler has 6 callback hooks:\n* Begin/End sampler\n* Begin/End protocol\n* Begin/End circuit\n\n\n5.3. Subset Sampler\n\nSamples only at one physical error rate pmax\nScaling obtained analytically\npmax must be chosen in “representative” region\n\nNote: 1. For multi-parameter error model pmax is a tuple of one physical error rate per group.\n2. The choice of pmax has a direct impact of which subsets are sampled.\nHow to choose pmax? What is the heuristic?\n* We want to sample, s.t. the subset occurence probability is max. for 0-weight subset and subsequently falling for higher order subsets.\n* We want to have also relatively high probability for other (important) subsets, i.e. weight-1, weight-2,..\nExample: For the Flagged-GHZ circuit we would choose a pmax close to 0.1:\n\nfrom qsample.sampler.base import subset_occurence, all_subsets, err_probs_tomatrix\n\ngrp = E1().group(ghz).values()\nwgts_combis = all_subsets(grp)\n\nfor p_phy in [0.01, 0.1, 0.3]:\n    Aws = subset_occurence(grp, wgts_combis, p_phy)\n    plt.figure()\n    plt.title(\"Subset occurence prob. $A_w$ at $p_{phy}$=%.2f\" % p_phy)\n    plt.bar(range(len(Aws)), Aws)\n    plt.ylabel(\"$A_w$\")\n    plt.xlabel(\"Subsets\")\n\n\n\n\n\n\n\n\n\n\n\nfrom qsample import SubsetSampler\n\n\npmax = {'q': 0.1}\n\nss_sam = SubsetSampler(ghz3, CHP,  pmax=pmax, err_probs=err_probs, err_model=E1)\nss_sam.run(300)\n\n\n\n\nNote: Although we passed err_probs those are not used for sampling. Only when we call stats() those probs are used:\n\np_L_low, std_low, p_L_up, std_up = ss_sam.stats()\n\nplt.errorbar(sample_range, p_L, fmt='--', c=\"black\", yerr=std, label=\"Direct MC\")\nplt.loglog(sample_range, p_L_low, label='SS low')\nplt.fill_between(sample_range, p_L_low - std_low, p_L_low + std_low, alpha=0.2)\nplt.loglog(sample_range, p_L_up, label='SS low')\nplt.fill_between(sample_range, p_L_up - std_up, p_L_up + std_up, alpha=0.2)\nplt.plot(sample_range, sample_range,'k:', alpha=0.5)\nplt.xlabel('$p_{phy}$(q)')\nplt.ylabel('$p_L$')\nplt.legend();\n\n\n\n\nWe sampled at a single error rate with much less samples and get a much better bound on the logical error rate. Let’s inspect what has been sampled:\n\nss_sam.tree.draw() # only one tree\n\n\n\n\nWe can store and later reload our sample results:\n\nss_sam.save('ghz3ss.samp')\n\nfrom qsample import Sampler\nstored_sam = Sampler.load('ghz3ss.samp')\ncounts_before = stored_sam.tree.root.counts\n\nstored_sam.run(200) # After loading we can for example run a few more samples.\ncounts_after = stored_sam.tree.root.counts\n\nprint(counts_before, counts_after)\n\nImportError: cannot import name 'Sampler' from 'qsample' (/home/dw/Desktop/HiWi/qsample/qsample/__init__.py)\n\n\nMore complex examples can be found here: https://github.com/dpwinter/qsample/blob/master/08_examples.ipynb"
  },
  {
    "objectID": "index.html#contribute",
    "href": "index.html#contribute",
    "title": "qsample",
    "section": "Contribute",
    "text": "Contribute\n\nsubmit your feature request via github issue"
  },
  {
    "objectID": "index.html#team",
    "href": "index.html#team",
    "title": "qsample",
    "section": "Team",
    "text": "Team\nqsample was developed by Don Winter based on and in collaboration with Sascha Heußen under supervision of Prof. Dr. Markus Müller."
  },
  {
    "objectID": "sampler.subset.html",
    "href": "sampler.subset.html",
    "title": "Subset Sampler",
    "section": "",
    "text": "from qsample.examples import ghz_stab, ftsteane, ghz3\nfrom qsample.noise import E1\nimport qsample.callbacks as cb\nfrom qsample.sim.stabilizer import StabilizerSimulator as CHP\nimport numpy as np\n\nsample_range = np.logspace(-7,0,10)\nerr_params = {'q': sample_range}\np_max = {'q': 0.1}\n\nss_sam = SubsetSamplerERV(ghz3, CHP, p_max=p_max, err_params=err_params, err_model=E1, k=1)\nss_sam.run(100, callbacks=[cb.PlotStats()])\nss_sam.tree.draw()\n\n\n\n\n\n\n\n\n\n\n\nss_sam = SubsetSamplerERV(ftsteane, CHP, p_max={\"q\": 0.01}, err_params=err_params, err_model=E1, k=10)\nss_sam.run(400, callbacks=[cb.PlotStats()])\nss_sam.tree.draw()\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\np_L_low, ss_std_low, p_L_up, ss_std_up = ss_sam.stats()\nplt.loglog(sample_range,ss_std_low)\nplt.loglog(sample_range,ss_std_up)"
  }
]