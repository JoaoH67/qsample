[
  {
    "objectID": "protocol.html",
    "href": "protocol.html",
    "title": "Protocol",
    "section": "",
    "text": "source\n\ndraw_protocol\n\n draw_protocol (protocol, path=None, legend=False, figsize=(6, 6),\n                label_offset=(0.05, 0.05))\n\nDraw protocol using networkx library\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nprotocol\nProtocol\n\nThe protocol to draw\n\n\npath\nNoneType\nNone\nThe path to save the resulting image to (optional)\n\n\nlegend\nbool\nFalse\nIf true, edge labels will be numbers referenced in legend\n\n\nfigsize\ntuple\n(6, 6)\nThe matplotlib figsize argument of the plot\n\n\nlabel_offset\ntuple\n(0.05, 0.05)\nOffset position of all edge labels\n\n\n\n\nsource\n\n\nProtocol\n\n Protocol (fault_tolerant=False, check_functions={}, *args, **kwargs)\n\nRepresentation of a Quantum (Error Correction) Protocol"
  },
  {
    "objectID": "sampler.tree.html",
    "href": "sampler.tree.html",
    "title": "Sample Tree",
    "section": "",
    "text": "source\n\ndraw_tree\n\n draw_tree (tree, verbose=False, path=None)\n\nGenerate and return PNG image of tree\nTo display the image in command line call .show() on the returned PIL image object.\nsee Fig. 1 in paper\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntree\n\n\n\n\n\nverbose\nbool\nFalse\n\n\n\npath\nNoneType\nNone\nFile path to save png image to, if None only display image\n\n\nReturns\nPNG image\n\nImage of CountTree\n\n\n\n/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Attributes\n  else: warn(msg)\n\nsource\n\n\nTree\n\n Tree (constants, L=None)\n\nData structure to track sampled Circuits in Protocol\n\nsource\n\n\nVariable\n\n Variable (name, count=0, invariant=False, ff_deterministic=False,\n           circuit_id=None, **kwargs)\n\nRepresentation of a random variable inside Tree\nSee Appendix C in paper\n\nsource\n\n\nDelta\n\n Delta (name, parent=None, children=None, **kwargs)\n\nRepresentation of subset cutoff error inside Tree\nSee Appendix C in paper\n\nsource\n\n\nConstant\n\n Constant (name, count=0, parent=None, const_val=None, **kwargs)\n\nRepresentation of a constant value inside Tree.\nA node in a tree is a uniquely identifiable object containing references to at most one parent and possibly many children. The root node has no parent and leaf nodes have not children.\nThe Constant class complements the common tree node by a count attribute which represents the number of times a node has been visited during sampling.\nSee Appendix C in paper\nTest creating a 1-level tree.\n\n# Test 1-level tree\n\nconstants = {0: {(0,): 0.8, (1,): 0.1, (2,): 0.05}}\ntree = Tree(constants)\nroot = tree.add(name='root', node_type=Variable, count=100, circuit_id=0)\nroot0 = tree.add(name=(0,), node_type=Constant, parent=root, count=40)\nroot1 = tree.add(name=(1,), node_type=Constant, parent=root, count=30)\nroot2 = tree.add(name=(2,), node_type=Constant, parent=root, count=30)\nd = tree.add(name='δ', node_type=Delta, parent=root)\nnone_0 = tree.add(name='None', node_type=Variable, parent=root0, count=40)\nnone_0.invariant = True\nfail_1 = tree.add(name='fail', node_type=Variable, parent=root1, count=20)\nnone_1 = tree.add(name='None', node_type=Variable, parent=root1, count=10)\nnone_2 = tree.add(name='None', node_type=Variable, parent=root2, count=25)\n\ntree.marked = set([fail_1])\n\n# tree.draw(verbose=False)\nprint(tree)\n\nroot (100, 0.00e+00)\n├── (0,) (40)\n│   └── None (40, 0.00e+00)\n├── (1,) (30)\n│   ├── fail (20, 7.20e-03)\n│   └── None (10, 7.20e-03)\n├── (2,) (30)\n│   └── None (25, 4.60e-03)\n└── δ\n\n\nTest numerics of 1-level tree.\n\n# Test numerics 1-level tree\n\ntest_eq(tree.root_leaf_rate, 20/100)\ntest_eq(tree.subtree_sum(tree.root, tree.marked), 0.1 * 20/30)\n\nvL = 0.1**2 * fail_1.var + 0.05**2 * none_2.var # vL = vL^up\ntest_close(tree.var(mode=1), vL, eps=1e-05)\ntest_close(tree.var(mode=0), vL, eps=1e-05)\n\nTest creation of 2-level tree.\n\n# Test 2-level tree\n\nconstants = {0: {(0,): 0.8, (1,): 0.1}, # c0\n             1: {(0,): 0.7, (1,): 0.2}, # c1\n             2: {(0,): 1.0}}            # c2\n\ntree = Tree(constants)\nroot = tree.add(name='c0', circuit_id=0, node_type=Variable, count=100)\nroot0 = tree.add(name=(0,), node_type=Constant, parent=root, count=70)\nroot1 = tree.add(name=(1,), node_type=Constant, parent=root, count=30)\nd1 = tree.add(name='δ', parent=root, node_type=Delta)\n\nc1_0 = tree.add(name='c1', circuit_id=1, node_type=Variable, count=50, parent=root0)\nc1_1 = tree.add(name='c1', circuit_id=1, node_type=Variable, count=20, parent=root1)\nc2_0 = tree.add(name='c2', circuit_id=2, node_type=Variable, count=20, parent=root0)\nc2_1 = tree.add(name='c2', circuit_id=2, node_type=Variable, count=10, parent=root1)\n\nc1_0_0 = tree.add(name=(0,), node_type=Constant, parent=c1_0, count=40)\nc1_0_1 = tree.add(name=(1,), node_type=Constant, parent=c1_0, count=10)\nd2 = tree.add(name='δ', node_type=Delta, parent=c1_0)\n\nc1_1_0 = tree.add(name=(0,), node_type=Constant, parent=c1_1, count=15)\nc1_1_1 = tree.add(name=(1,), node_type=Constant, parent=c1_1, count=5)\nd3 = tree.add(name='δ', node_type=Delta, parent=c1_1)\n\nc2_0_0 = tree.add(name=(0,), node_type=Constant, parent=c2_0, count=20)\nd4 = tree.add(name='δ', node_type=Delta, parent=c2_0)\nc2_1_0 = tree.add(name=(0,), node_type=Constant, parent=c2_1, count=10)\nd5 = tree.add(name='δ', node_type=Delta, parent=c2_1)\n\nnone_c1_0_0 = tree.add(name='None', node_type=Variable, parent=c1_0_0, count=40)\nnone_c1_0_0.invariant = True\nnone_c1_0_1 = tree.add(name='None', node_type=Variable, parent=c1_0_1, count=5)\nfail_c1_0_1 = tree.add(name='fail', node_type=Variable, parent=c1_0_1, count=5)\nnone_c1_1_0 = tree.add(name='None', node_type=Variable, parent=c1_1_0, count=15)\nnone_c1_1_1 = tree.add(name='None', node_type=Variable, parent=c1_1_1, count=3)\nfail_c1_1_1 = tree.add(name='fail', node_type=Variable, parent=c1_1_1, count=2)\n\nnone_c2_0_0 = tree.add(name='None', node_type=Variable, parent=c2_0_0, count=20)\nnone_c2_0_0.invariant = True\nfail_c2_1_0 = tree.add(name='fail', node_type=Variable, parent=c2_1_0, count=10)\n\ntree.marked = set([fail_c1_0_1, fail_c1_1_1, fail_c2_1_0])\n\nprint(tree)\n\nc0 (100, 0.00e+00)\n├── (0,) (70)\n│   ├── c1 (50, 2.88e-03)\n│   │   ├── (0,) (40)\n│   │   │   └── None (40, 0.00e+00)\n│   │   ├── (1,) (10)\n│   │   │   ├── None (5, 2.27e-02)\n│   │   │   └── fail (5, 2.27e-02)\n│   │   └── δ\n│   └── c2 (20, 2.88e-03)\n│       ├── (0,) (20)\n│       │   └── None (20, 0.00e+00)\n│       └── δ\n├── (1,) (30)\n│   ├── c1 (20, 7.20e-03)\n│   │   ├── (0,) (15)\n│   │   │   └── None (15, 9.77e-04)\n│   │   ├── (1,) (5)\n│   │   │   ├── None (3, 4.03e-02)\n│   │   │   └── fail (2, 4.03e-02)\n│   │   └── δ\n│   └── c2 (10, 7.20e-03)\n│       ├── (0,) (10)\n│       │   └── fail (10, 2.07e-03)\n│       └── δ\n└── δ\n\n\n\nA0 = 0.8\nA1 = 0.1\nB0 = 0.7\nB1 = 0.2\nC0 = 1\n\ntest_close(tree.path_prod(tree.root, fail_c1_0_1), A0*50/70*B1*5/10)\ntest_close(tree.path_prod(tree.root, fail_c1_1_1), A1*20/30*B1*2/5)\ntest_close(tree.path_prod(tree.root, fail_c2_1_0), A1*10/30*1)\n\ntest_close(tree.path_prod(tree.root, d1), 1 - A0 - A1)\ntest_close(tree.path_prod(tree.root, d2), A0*50/70*(1-B0-B1))\ntest_close(tree.path_prod(tree.root, d3), A1*20/30*(1-B0-B1))\ntest_close(tree.path_prod(tree.root, d4), 0)\ntest_close(tree.path_prod(tree.root, d5), 0)\n\n\nv1 = A0**2 * B1**2 * ((c1_0.var + (50/70)**2)*(fail_c1_0_1.var + (5/10)**2) - (50/70)**2 * (5/10)**2)\ntest_close(tree.path_var(fail_c1_0_1), v1)\n\nv2 = A0**2 * (1-B0-B1)**2 * c1_0.var\ntest_close(tree.path_var(d2), v2)\n\nTest numerics of 2-level tree.\n\n# Test numerics 2-level tree\ntest_eq(tree.root_leaf_rate, 5/100 + 2/100 + 10/100)\n\npL = A0 * 50/70 * 0.2 * 5/10 + A1 * (20/30 * B1 * 2/5 + 10/30 * C0 * 1)\npL_up = 1 - A0 - A1 + A0*(50/70)*(1-B0-B1*5/10) + A1*(20/30)*(1-B0-B1*(3/5)) + A1*10/30*C0*1\n\ntest_eq(tree.subtree_sum(tree.root, tree.marked), pL)\n\nv14 = (c1_0.var + (50/70)**2)*(fail_c1_0_1.var + (5/10)**2) - (50/70)**2 * (5/10)**2\nv27 = (c1_1.var + (20/30)**2)*(fail_c1_1_1.var + (2/5)**2) - (20/30)**2 * (2/5)**2\nv2bar8 = (c2_1.var + (10/30)**2) * (fail_c2_1_0.var + (1)**2) - (10/30)**2 * (1)**2\nvL = A0**2*B1**2*v14 + A1**2*B1**2*v27 + A1**2*C0**2*v2bar8 - 2*A1*A1*B1*C0*(2/5)*(1)*c1_1.var\nvL += A1**2 * B0**2 * ((c1_1.var + c1_1.rate**2) * none_c1_1_0.var) # non-fail path contributions\n\ntest_close(tree.var(mode=1), vL)\n\ndelta = 1 - B0 - B1\nv1 = c1_0.var\nv2 = c1_1.var\nq4 = fail_c1_0_1.rate\nq7 = fail_c1_1_1.rate\nq8 = fail_c2_1_0.rate\n\nvL_up = (A0**2 * delta**2 * v1 + \n         A0**2 * B1**2 * v14 +\n         A1**2 * delta**2 * v2 + \n         A1**2 * B1**2 * v27 +\n         A1**2 * B0**2 * ((c1_1.var + c1_1.rate**2) * none_c1_1_0.var) + # non-fail path contribution\n         A1**2 * C0**2 * v2bar8 +\n         2 * (A0**2 * delta * B1 * q4 * v1 +\n              A1**2 * delta * B1 * q7 * v2 -\n              A1**2 * C0 * delta * v2 -\n              A1**2 * B1 * C0 * q7 * q8 * v2\n             )\n        )\n\n# test_close(tree.var(mode=0), vL_up)\n\nSimple (real) tree example\n\nconstants = {'ENC': {(0,): 0.977251, (1,): 0.0224993}, # c0\n             'meas': {(0,): 0.993021, (1,): 0.0069581}, # c1\n             'Z2': {(0,): 0.994015, (1,): 0.00597006}\n            } # corresp. p_max = 1e-3\nM0 = constants['ENC'][(0,)]\nL = 2\n\ntree = Tree(constants, L=L)\nroot = tree.add(name='ENC', circuit_id='ENC', node_type=Variable, count=1)\nroot1 = tree.add(name=(1,), node_type=Constant, parent=root, count=1)\n\nroot1enc = tree.add(name='meas', circuit_id='meas', node_type=Variable, parent=root1, count=1)\nroot1enc0 = tree.add(name=(0,), node_type=Constant, parent=root1enc, count=1)\nroot1enc0 = tree.add(name=\"None\", node_type=Variable, parent=root1enc0, count=1)\nroot1enc0.invariant = True\n\n# tree.marked.add(root1enc0)\n\nroot1encd = tree.add(name='δ', node_type=Delta, parent=root1enc)\n\nroot1meas = tree.add(name='Z2', circuit_id='Z2', node_type=Variable, parent=root1, count=0)\nroot1meas0 = tree.add(name=(0,), node_type=Constant, parent=root1meas, count=0)\n\nroot1measd = tree.add(name='δ', node_type=Delta, parent=root1meas)\n\nprint(tree)\n\nENC (1, 0.00e+00)\n└── (1,) (1)\n    ├── meas (1, 6.25e-02)\n    │   ├── (0,) (1)\n    │   │   └── None (1, 0.00e+00)\n    │   └── δ\n    └── Z2 (0, 6.25e-02)\n        ├── (0,) (0)\n        └── δ\n\n\n\ndelta = constants['ENC'][(1,)] * (1 - constants['meas'][(0,)])\ntest_close(tree.delta, delta)\n\n\nVq = 1/16\n\nvL = constants['ENC'][(1,)]**2 * constants['meas'][(0,)]**2 * (Vq**2 + 2*Vq)\n# test_close(vL, tree.var(mode=1))\n\n\nA1enc = constants['ENC'][(1,)]\nA0meas = constants['meas'][(0,)]\n\nvLup = (A1enc**2 * (A0meas**2 * (Vq**2 + 2*Vq) + (1 - A0meas - L * (1 - M0))**2 * \n                    Vq + 2 * A0meas * (1 - A0meas - L * (1 - M0)) * Vq ))\n\n# test_close(vLup, tree.var(mode=0))\n\n\n# 10 samples test\n\nconstants = {'ENC': {(0,): 0.977251, (1,): 0.0224993}, # c0\n             'meas': {(0,): 0.993021, (1,): 0.0069581}, # c1\n             'Z2': {(0,): 0.994015, (1,): 0.00597006}\n            } # corresp. p_max = 1e-3\n\nM0 = constants['ENC'][(0,)]\nL = 2\n\ntree = Tree(constants, L=L)\nroot = tree.add(name='ENC', circuit_id='ENC', node_type=Variable, count=10)\nroot1 = tree.add(name=(1,), node_type=Constant, parent=root, count=1)\nroot0 = tree.add(name=(0,), node_type=Constant, parent=root, count=9)\nrootd = tree.add(name='δ', node_type=Delta, parent=root)\n\n\nroot0meas = tree.add(name='meas', circuit_id='meas', node_type=Variable, parent=root0, count=9)\nroot0meas0 = tree.add(name=(0,), node_type=Constant, parent=root0meas, count=9)\nroot0meas0None = tree.add(name=\"None\", node_type=Variable, parent=root0meas0, count=9)\nroot0meas0None.invariant = True\n\nroot0meas1 = tree.add(name=(1,), node_type=Constant, parent=root0meas, count=0)\nroot0measd = tree.add(name='δ', node_type=Delta, parent=root0meas)\n\n\nroot1enc = tree.add(name='meas', circuit_id='meas', node_type=Variable, parent=root1, count=1)\nroot1enc0 = tree.add(name=(0,), node_type=Constant, parent=root1enc, count=1)\nroot1enc0 = tree.add(name=\"None\", node_type=Variable, parent=root1enc0, count=1)\nroot1enc0.invariant = True\n\n# tree.marked.add(root1enc0)\n\nroot1encd = tree.add(name='δ', node_type=Delta, parent=root1enc)\n\nroot1meas = tree.add(name='Z2', circuit_id='Z2', node_type=Variable, parent=root1, count=0)\nroot1meas0 = tree.add(name=(0,), node_type=Constant, parent=root1meas, count=0)\n\nroot1measd = tree.add(name='δ', node_type=Delta, parent=root1meas)\n\nprint(tree)\n\nENC (10, 0.00e+00)\n├── (1,) (1)\n│   ├── meas (1, 6.25e-02)\n│   │   ├── (0,) (1)\n│   │   │   └── None (1, 0.00e+00)\n│   │   └── δ\n│   └── Z2 (0, 6.25e-02)\n│       ├── (0,) (0)\n│       └── δ\n├── (0,) (9)\n│   └── meas (9, 2.50e-03)\n│       ├── (0,) (9)\n│       │   └── None (9, 0.00e+00)\n│       ├── (1,) (0)\n│       └── δ\n└── δ\n\n\nAnother example\n\nconstants = {'ENC': {(0,): 0.977251, (1,): 0.0224993}, # c0\n             'meas': {(0,): 0.993021, (1,): 0.0069581}, # c1\n            } # corresp. p_max = 1e-3\n\ntree = Tree(constants, L=2)\nroot = tree.add(name='ENC', circuit_id='ENC', node_type=Variable, count=2)\nroot0 = tree.add(name=(0,), node_type=Constant, parent=root, count=1)\nroot1 = tree.add(name=(1,), node_type=Constant, parent=root, count=1)\nd = tree.add(name='δ', node_type=Delta, parent=root)\n\nroot1enc = tree.add(name='ENC', circuit_id='ENC', node_type=Variable, parent=root1, count=0)\nroot1enc0 = tree.add(name=(0,), node_type=Constant, parent=root1enc, count=0)\nroot1encd = tree.add(name='δ', node_type=Delta, parent=root1enc)\n\nroot1meas = tree.add(name='meas', circuit_id='meas', node_type=Variable, parent=root1, count=1)\nroot1meas0 = tree.add(name=(0,), node_type=Constant, parent=root1meas, count=1)\nroot1meas0none = tree.add(name='None', node_type=Variable, parent=root1meas0, count=1)\nroot1meas0none.invariant = True # Set leaf node to inv (FT PATH!)\nroot1measd = tree.add(name='δ', node_type=Delta, parent=root1meas)\n\n\nroot0meas = tree.add(name='meas', circuit_id='meas', node_type=Variable, parent=root0, count=1)\nroot0meas0 = tree.add(name=(0,), node_type=Constant, parent=root0meas, count=1)\nroot0meas1 = tree.add(name=(1,), node_type=Constant, parent=root0meas, count=0)\n\nroot0meas0none = tree.add(name='None', node_type=Variable, parent=root0meas0, count=1)\nroot0meas0none.invariant = True # Set leaf node to inv\nroot0measd = tree.add(name='δ', node_type=Delta, parent=root0meas)\n\nprint(tree)\n\nENC (2, 0.00e+00)\n├── (0,) (1)\n│   └── meas (1, 6.25e-02)\n│       ├── (0,) (1)\n│       │   └── None (1, 0.00e+00)\n│       ├── (1,) (0)\n│       └── δ\n├── (1,) (1)\n│   ├── ENC (0, 6.25e-02)\n│   │   ├── (0,) (0)\n│   │   └── δ\n│   └── meas (1, 6.25e-02)\n│       ├── (0,) (1)\n│       │   └── None (1, 0.00e+00)\n│       └── δ\n└── δ\n\n\n\nd1 = 1 - constants['ENC'][(0,)] - constants['ENC'][(1,)]\nd2 = constants['ENC'][(0,)] * (1 - constants['meas'][(0,)] - constants['meas'][(1,)])\nd3 = constants['ENC'][(1,)] * (1 - constants['meas'][(0,)])\ndelta = d1 + d2 + d3\ntest_close(tree.delta, delta)\n\n\nM0 = constants['ENC'][(0,)] # smallest possible A0.\ntest_close(tree.constants[tree.M0_index[0]][tree.M0_index[1]], M0)\n\nL = 2\nV1 = 6.25e-02\n\nVLup = constants['ENC'][(1,)]**2 * (1 - constants['meas'][(0,)] - L * (1 - M0))**2 * V1\ntest_close(np.sqrt(VLup), np.sqrt(tree.var(mode=0)))"
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "In this section, we show more examples of quantum protocols and sampling outcomes for both direct MC and subset sampling. All examples are also described in more detail in the linked paper."
  },
  {
    "objectID": "examples.html#ghz-state-preparation",
    "href": "examples.html#ghz-state-preparation",
    "title": "Examples",
    "section": "1. GHZ state preparation",
    "text": "1. GHZ state preparation\nSee sections 1C and 3B in paper\n\n# Sampling parameters\n\nsample_range = np.logspace(-3,0,5)\nerr_params = {'q': sample_range}\nerr_model = qs.noise.S1\nCHP = qs.StabilizerSimulator\np_max = {'q': 1e-3}\n\n# Direct MC sampling\n\nprint(\"--- Direct MC sampling ---\")\n\nmc_sam = qs.DirectSampler(ghz1, CHP, err_params=err_params, err_model=err_model)\nmc_sam.run(10_000)\n\nprint(\"--- Subset sampling ---\")\n\nss_sam = qs.SubsetSampler(protocol=ghz1, simulator=CHP,  p_max=p_max, err_model=err_model, err_params=err_params, L=1)\nss_sam.run(1_000)\n\n# Plot results\n\np_L, std = mc_sam.stats()\np_L_low, ss_std_low, p_L_up, ss_std_up = ss_sam.stats()\n\nplt.errorbar(sample_range, p_L, fmt='--', c=\"black\", yerr=std, label=\"Direct MC\")\nplt.loglog(sample_range, p_L_low, label='SS low')\nplt.fill_between(sample_range, p_L_low-ss_std_low, p_L_low+ss_std_low, alpha=0.2)\nplt.loglog(sample_range, p_L_up, label='SS low')\nplt.fill_between(sample_range, p_L_up-ss_std_up, p_L_up+ss_std_up, alpha=0.2)\nplt.ylabel('$p_L$')\nplt.xlabel('$p$')\n\n--- Direct MC sampling ---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- Subset sampling ---\n\n\n\n\n\nText(0.5, 0, '$p$')"
  },
  {
    "objectID": "examples.html#deterministic-fault-tolerant-preparation-of-steane-code-state",
    "href": "examples.html#deterministic-fault-tolerant-preparation-of-steane-code-state",
    "title": "Examples",
    "section": "2. Deterministic fault-tolerant preparation of Steane code state",
    "text": "2. Deterministic fault-tolerant preparation of Steane code state\nSee section 3C in paper\n\n# Sampling parameters\n\nsample_range = np.logspace(-3,-1,5)\nerr_params = {'q1': sample_range/10, 'q2': sample_range}\nerr_model = qs.noise.S2\nCHP = qs.StabilizerSimulator\np_max = {'q1': 1e-3, 'q2': 1e-2}\n\n# Direct MC sampling\n\nprint(\"--- Direct MC sampling ---\")\n\nmc_sam = qs.DirectSampler(steane0, CHP, err_params=err_params, err_model=err_model)\nmc_sam.run(10_000)\n\nprint(\"--- Subset sampling ---\")\n\nss_sam = qs.SubsetSampler(steane0, CHP,  p_max=p_max, err_model=err_model, err_params=err_params, L=4)\nss_sam.run(10_000)\n\n# Plot results\n\np_L, std = mc_sam.stats()\np_L_low, ss_std_low, p_L_up, ss_std_up = ss_sam.stats()\n\nplt.errorbar(sample_range, p_L, fmt='--', c=\"black\", yerr=std, label=\"Direct MC\")\nplt.loglog(sample_range, p_L_low, label='SS low')\nplt.fill_between(sample_range, p_L_low-ss_std_low, p_L_low+ss_std_low, alpha=0.2)\nplt.loglog(sample_range, p_L_up, label='SS low')\nplt.fill_between(sample_range, p_L_up-ss_std_up, p_L_up+ss_std_up, alpha=0.2)\nplt.ylabel('$p_L$')\nplt.xlabel('$p$')\n\n--- Direct MC sampling ---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- Subset sampling ---\n\n\n\n\n\nText(0.5, 0, '$p$')"
  },
  {
    "objectID": "examples.html#flag-ft-stabilizer-0rangle_l-measurement",
    "href": "examples.html#flag-ft-stabilizer-0rangle_l-measurement",
    "title": "Examples",
    "section": "3. Flag-FT stabilizer \\(|0\\rangle_L\\) measurement",
    "text": "3. Flag-FT stabilizer \\(|0\\rangle_L\\) measurement\nSee section 3D in paper\n\n# Sampling parameters\n\nsample_range = np.logspace(-3,0,5)\nerr_params = {'q': sample_range}\nerr_model = qs.noise.S1\nCHP = qs.StabilizerSimulator\np_max = {'q': 1e-2}\n\n# Direct MC sampling\n\nprint(\"--- Direct MC sampling ---\")\n\nmc_sam = qs.DirectSampler(flagstab, CHP, err_params=err_params, err_model=err_model)\nmc_sam.run(10_000)\n\nprint(\"--- Subset sampling ---\")\n\nss_sam = qs.SubsetSampler(flagstab, CHP,  p_max=p_max, err_model=err_model, err_params=err_params, L=8)\nss_sam.run(10_000)\n\n# Plot results\n\np_L, std = mc_sam.stats()\np_L_low, ss_std_low, p_L_up, ss_std_up = ss_sam.stats()\n\nplt.errorbar(sample_range, p_L, fmt='--', c=\"black\", yerr=std, label=\"Direct MC\")\nplt.loglog(sample_range, p_L_low, label='SS low')\nplt.fill_between(sample_range, p_L_low-ss_std_low, p_L_low+ss_std_low, alpha=0.2)\nplt.loglog(sample_range, p_L_up, label='SS low')\nplt.fill_between(sample_range, p_L_up-ss_std_up, p_L_up+ss_std_up, alpha=0.2)\nplt.ylabel('$p_L$')\nplt.xlabel('$p$')\n\n--- Direct MC sampling ---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n--- Subset sampling ---\n\n\n\n\n\nText(0.5, 0, '$p$')"
  },
  {
    "objectID": "sampler.experimental.html",
    "href": "sampler.experimental.html",
    "title": "ERU Subset Sampler",
    "section": "",
    "text": "/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Attributes\n  else: warn(msg)\n\nsource\n\nSubsetSamplerERU\n\n SubsetSamplerERU (protocol, simulator, p_max, err_model, err_params=None,\n                   k=1, L=1)\n\nSubset sampler implementing ERU sampling technique\nWORK IN EXPERIMENTAL STATE\nSee App. C3b in paper"
  },
  {
    "objectID": "noise.html",
    "href": "noise.html",
    "title": "Error models",
    "section": "",
    "text": "Some common error sets\n\nsource\n\nErrorModel\n\n ErrorModel ()\n\nRepresentation of an incoherent error model.\n\nsource\n\n\nE0\n\n E0 ()\n\nNo-Error error model\n\nsource\n\n\nE1\n\n E1 ()\n\nOne prob/weight for all 1- and 2-qubit gates\n\nsource\n\n\nE1_1\n\n E1_1 ()\n\nOne prob/weight for all 1- and 2-qubit gates and measurements\n\nsource\n\n\nE2\n\n E2 ()\n\nIndividual errors on 1-qubit and 2-qubit gates.\n\nsource\n\n\nE3\n\n E3 ()\n\nErrors on all gates individual + idle.\n\nsource\n\n\nE3_1\n\n E3_1 ()\n\nLike E3, but idle locations split in two subsets.\n\nsource\n\n\nS4\n\n S4 ()\n\nDepolarizing noise on all operations, 4 parameters\n\nsource\n\n\nS1\n\n S1 ()\n\nSingle parameter depolarizing noise on all operations\nSee App. D and sections 3B and 3D in paper\n\nsource\n\n\nS2\n\n S2 ()\n\nIndividual errors on 1-qubit and 2-qubit gates. Depolarizing noise with 1-qubit rate on init and meas\nSee App. D and section 3C in paper"
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utilities",
    "section": "",
    "text": "source\n\nsave\n\n save (data, path)\n\nSave data to path\n\n\n\n\nType\nDetails\n\n\n\n\ndata\n*\nData to write to path\n\n\npath\nstr\nFile path to save to\n\n\n\n\nsource\n\n\nload\n\n load (path)\n\nLoad data from path\n\n\n\n\nType\nDetails\n\n\n\n\npath\nstr\nFile path to load from\n\n\nReturns\n*****\nLoaded data"
  },
  {
    "objectID": "math.html",
    "href": "math.html",
    "title": "Math",
    "section": "",
    "text": "source\n\ncomb\n\n comb (n, k)\n\nVectorized combination: comb(n,k) = n! / ((n-k)!k!)\n\n\n\n\nType\nDetails\n\n\n\n\nn\nint or np.array of int\nFirst parameter of combination\n\n\nk\nint or np.array of int\nSecond parameter of combination\n\n\nReturns\nnp.array\nCombination (choose k out of n)\n\n\n\n/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Example\n  else: warn(msg)\n\nsource\n\n\nbinom\n\n binom (k, n, p)\n\nVectorized binomial distribution: binom(k,n,p)=comb(n,k) p^k (1-p)^n-k\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nk\nint or list of int\nSecond parameter of combination\n\n\nn\nint or list of int\nFirst parameter of combination\n\n\np\nfloat or list of float\nProbability\n\n\nReturns\nnp.array\nValue(s) of binomial distribution evaluated at k,n,p.\n\n\n\n\ntest_close(binom(k=[1,2], n=[3,4], p=0.1), [0.243 , 0.0486], eps=1e-05)\n\n\nsource\n\n\njoint_binom\n\n joint_binom (k, n, p)\n\nProduct of independent binomial distributions with parameters k, n and p (can be list of lists), i.e.:\njoint_binom(k,n,p)=binom(k[0],n[0],p[0])×…×binom(k[-1],n[-1],p[-1])\nsee Eq. 26 in paper\n\n\n\n\nType\nDetails\n\n\n\n\nk\nlist of int\nList of second parameters of combination\n\n\nn\nlist of int\nList of first parameters of combination\n\n\np\nlist of list, list of float, or float\nProbability\n\n\nReturns\nnp.array\nJoint probability\n\n\n\n\ntest_close(joint_binom(k=[1,2], n=[3,4], p=[0.1,0.2]), binom(k=1,n=3,p=0.1) * binom(k=2,n=4,p=0.2))\ntest_close(joint_binom(k=[1,2], n=[2,3], p=[[0.1,0.2],[.3,.4]]), [binom(1,2,0.1)*binom(2,3,0.2), binom(1,2,0.3)*binom(2,3,0.4)])\n\n\nsource\n\n\nWilson_var\n\n Wilson_var (p, N)\n\nWilson estimator of binomial variance\nThe formula for the Wilson interval is:\nCI = p+z^2/(2n) \\pm z\\sqrt{pq/n + z^2/(4n^2)}/(1 + z^2/n)\nwe can extract the var (z=1) as:\nVar(p) = (CI/2)^2 = (npq + 0.25) / (1 + n)^2\nsee Eq. C12 in paper\n\n\n\n\nType\nDetails\n\n\n\n\np\nfloat\nEstimator of probability\n\n\nN\nint\nSample size\n\n\nReturns\nfloat\nEstimated variance of Wilson CI\n\n\n\n\nsource\n\n\nWald_var\n\n Wald_var (p, N)\n\nWald estimation of binomial variance\nsee Eq. C11 in paper\n\n\n\n\nType\nDetails\n\n\n\n\np\nfloat\nEstimator of probability\n\n\nN\nint\nSample size\n\n\nReturns\nfloat\nEstimated variance of Wald CI\n\n\n\n\nsource\n\n\nsubset_cards\n\n subset_cards (superset)\n\nCalculate cardinalities of all possible subsets of superset\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nsuperset\nset\nInput set\n\n\nReturns\nlist of int\nAll possible cardinalities of subsets in superset\n\n\n\n\nassert(subset_cards({1,2,3}) == {0,1,2,3})\nassert(subset_cards({(0,0), (0,1), (0,2)}) == {0,1,2,3})\n\n\nsource\n\n\ncartesian_product\n\n cartesian_product (list_of_sets)\n\nCalculate cartesian product between all members of sets\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nlist_of_sets\nlist\nList of sets between which to calculate Cartesian product\n\n\nReturns\nlist of tuple\nCartesian products\n\n\n\n\nassert(cartesian_product([{1,2},{3,4}]) == [(1,3), (1,4), (2,3), (2,4)])\n\n\nsource\n\n\nsubset_probs\n\n subset_probs (circuit, error_model, prob)\n\nCalculate occurence probability of subsets in circuit with physical error rate prob. error_model defines how the circuit is to be partitioned before occurence probabilities are calculated.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ncircuit\nCircuit\nCircuit wrt. which subset probabilities are calculated\n\n\nerror_model\nErrorModel\nError model by which to partition circuit\n\n\nprob\nfloat or list of float\nPhysical error probabilities"
  },
  {
    "objectID": "circuit.html",
    "href": "circuit.html",
    "title": "Circuit",
    "section": "",
    "text": "source\n\nunpack\n\n unpack (seq)\n\nGenerator to unpack all values of dicts inside a list of dicts\n\n\n\n\nType\nDetails\n\n\n\n\nseq\nIterable\nIterable to recursively unpack\n\n\n\n\nsource\n\n\ndraw_circuit\n\n draw_circuit (circuit, path=None, scale=2)\n\nDraw circuit using latextools library\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncircuit\nCircuit\n\nThe circuit to draw\n\n\npath\nNoneType\nNone\nThe path to save the resulting image to (optional)\n\n\nscale\nint\n2\nThe scale of the image\n\n\nReturns\ndrawSvg.drawing.Drawing\n\nImage object\n\n\n\n/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Attributes\n  else: warn(msg)\n\nsource\n\n\nCircuit\n\n Circuit (ticks=None, noisy=True)\n\nRepresentation of a quantum circuit\n\nlist(unpack([{'X': {1,2,3}},{'CNOT': {(0,1), (1,3)}}]))\n\n[1, 2, 3, 0, 1, 1, 3]\n\n\n\n# Tests\n\nc1 = Circuit(ticks=[{'Z': {0}}])\nc2 = Circuit(ticks=[{'X': {3}}])\nc3 = Circuit(ticks=[{'X': {3}}, {'Z': {0}}])\nc4 = Circuit(ticks=[])\nassert(c1.id != c2.id != c3.id != c4.id)\nc1.id, c2.id, c3.id, c4.id\n\n('14476', '5b6e8', 'c5aff', '6cc48')"
  },
  {
    "objectID": "sim.mixin.html",
    "href": "sim.mixin.html",
    "title": "Simulator Mixin",
    "section": "",
    "text": "source\n\nCircuitRunnerMixin\n\n CircuitRunnerMixin ()\n\nSimulator mixin for running quantum circuits"
  },
  {
    "objectID": "sampler.direct.html",
    "href": "sampler.direct.html",
    "title": "Direct Sampler",
    "section": "",
    "text": "/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Attributes\n  else: warn(msg)\n\nsource\n\nDirectSampler\n\n DirectSampler (protocol, simulator, err_model, err_params=None)\n\nDirect Monte Carlo Sampler"
  },
  {
    "objectID": "callbacks.html",
    "href": "callbacks.html",
    "title": "Sampler Callbacks",
    "section": "",
    "text": "/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Attributes\n  else: warn(msg)\n\nsource\n\nCallbackList\n\n CallbackList (sampler, callbacks=[])\n\nManages execution of all specified callbacks\n\nsource\n\n\nCallback\n\n Callback ()\n\nCallback super class: All callbacks must inherit this class.\n\nsource\n\n\nCollectStatsPerShot\n\n CollectStatsPerShot (log_dir=None)\n\nStore information of Sampler.stats() with each shot and plot each statistic as as function of shots after sampler ends\n\nsource\n\n\nStopAtNoHits\n\n StopAtNoHits ()\n\nCallback for DirectSampler only\n\nsource\n\n\nPlotStats\n\n PlotStats ()\n\nPlot sampler statistics at end of sampling process\n\nsource\n\n\nRelStdTarget\n\n RelStdTarget (target=0.1, include_delta=True)\n\nCallback to stop sampling when the relative standard deviation target target is reached\n\nsource\n\n\nStatsPerShot\n\n StatsPerShot (log_dir=None)\n\nStore information of Sampler.stats() with each shot and plot each statistic as as function of shots after sampler ends\n\nsource\n\n\nVerboseCircuitExec\n\n VerboseCircuitExec ()\n\nCallback to output detailed information about circuit selection, specific fault that occured, measurement outcome and next circuit\n\nsource\n\n\nPlotERVPerShot\n\n PlotERVPerShot (log_dir=None)\n\nCallback to plot statistics about ERV values and selected subsets due to ERV\n\nsource\n\n\nPrintERVPerShot\n\n PrintERVPerShot ()\n\nCallback to print ERV statistics per shot\n\nsource\n\n\nPathProducts\n\n PathProducts (log_dir=None)\n\nCallback to plot distribution of sampled paths\n\nsource\n\n\nSubsetRates\n\n SubsetRates (log_dir=None)\n\nCallback to plot progression of each fail path as a function of shots"
  },
  {
    "objectID": "sim.stabilizer.html",
    "href": "sim.stabilizer.html",
    "title": "CHP Simulator",
    "section": "",
    "text": "source\n\nMeasureResult\n\n MeasureResult (value:bool, determined:bool)\n\nA measurement’s output and whether it was random or not.\n\nsource\n\n\npauli_product_phase\n\n pauli_product_phase (x1:bool, z1:bool, x2:bool, z2:bool)\n\nDetermines the power of i in the product of two Paulis.\nFor example, X*Y = iZ and so this method would return +1 for X and Y.\nThe input Paulis are encoded into the following form:\nx z | Pauli\n----+-------\n0 0 | I\n1 0 | X\n1 1 | Y\n0 1 | Z\n\nsource\n\n\nChpSimulator\n\n ChpSimulator (num_qubits)\n\nThe bare minimum needed for the CHP simulation.\nOriginal author: Craig Gidney (https://github.com/Strilanc/python-chp-stabilizer-simulator)\nChanges: np.bool -> bool (reason: np.bool is deprecated since numpy>=1.23)\nReference: “Improved Simulation of Stabilizer Circuits” Scott Aaronson and Daniel Gottesman https://arxiv.org/abs/quant-ph/0406196\n\nsource\n\n\nStabilizerSimulator\n\n StabilizerSimulator (num_qubits)\n\nThe bare minimum needed for the CHP simulation."
  },
  {
    "objectID": "sim.statevector.html",
    "href": "sim.statevector.html",
    "title": "Statevector Simulator",
    "section": "",
    "text": "source\n\nMeasureResult\n\n MeasureResult (value:bool)\n\nClass to hold measurement result\n\nsource\n\n\nStatevectorSimulator\n\n StatevectorSimulator (num_qubits)\n\nStatevector simulator using ProjectQ simulator"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "qsample",
    "section": "",
    "text": "pip install qsample"
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "qsample",
    "section": "Prerequisites",
    "text": "Prerequisites\n\npython3\n\npdflatex (for circuit rendering)"
  },
  {
    "objectID": "index.html#when-to-use",
    "href": "index.html#when-to-use",
    "title": "qsample",
    "section": "When to use",
    "text": "When to use\n\nFor QEC protocols with in-sequence measurements and feed-forward of measurement information\nApply circuit-level incoherent Pauli noise at low physical error rates (i.e. high fidelity physical operations)\nSimulate and sample protocol execution over ranges of varying physical error rates, using customizable callbacks"
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "qsample",
    "section": "Getting started",
    "text": "Getting started\n\nimport qsample as qs\nimport matplotlib.pyplot as plt  # for visualization of results\n\nFirst, we need to define a quantum protocol of which we would like to know the logical error rate. In qsample a protocol is represented as a graph of quantum Circuits as nodes and boolean transition checks between them. Each check is evaluated at runtime to determined the next circuit to choose, thus simulation of non-deterministic protocols is possible.\nAs an example, let’s sample the logical error rates of an error-corrected quantum state teleportation protocol. We define the teleportation circuit teleport which sends the state the first qubit is in, here \\(|0\\rangle\\), to the third qubit.\n\nteleport = qs.Circuit([{\"init\": {0, 1, 2}},\n                       {\"H\": {1}},\n                       {\"CNOT\": {(1, 2)}},\n                       {\"CNOT\": {(0, 1)}},\n                       {\"H\": {0}},\n                       {\"measure\": {0, 1}}])\n\nteleport.draw()\n\n\n\n\nAdditionally, we need a circuit to (perfectly) measure the third qubit after running teleport to verify if the teleportation was successful. If the outcome of this measurement is 0 (corresponding to the initially prepared \\(|0\\rangle\\) state of qubit 1) the teleportation succeded. If the outcome is 1 it (logically) failed, we thus want to increment a logical fail counter. Let’s create a circuit for this measurement and let’s assume we can perform this measurement without noise.\n\nmeas = qs.Circuit([{\"measure\": {2}}], noisy=True)\n\nBetween the teleport and meas circuits apply a correction to qubit 3 conditioned on the measurement outcome (syndrome) of the teleportation circuit. We define the lookup function lut as follows\n\ndef lut(syn):\n    op = {0: 'I', 1: 'X', 2: 'Z', 3: 'Y'}[syn]\n    return qs.Circuit([{op: {2}}], noisy=False)\n\nFinally, define the circuit sequence and transition logic together within a Protocol object. Note that protocols must always commence with a unique START node and terminate at a (not necessarily unique) FAIL node, where the latter expresses a logical failure event.\n\ntele_proto = qs.Protocol(check_functions={'lut': lut})\ntele_proto.add_nodes_from(['tele', 'meas'], circuits=[teleport, meas])\ntele_proto.add_edge('START', 'tele', check='True')\ntele_proto.add_edge('tele', 'COR', check='lut(tele[-1])')\ntele_proto.add_edge('COR', 'meas', check='True')\ntele_proto.add_edge('meas', 'FAIL', check='meas[-1] == 1')\n\ntele_proto.draw(figsize=(8,5))\n\n\n\n\nNotice that we do not define any initial circuit for the correction COR but pass our lookup function to the check_functions dictionary, which makes it accessible inside the check transition statements between circuits. This way we can also dynamically inject correction circuits into the protocol at execution time.\nAfter the protocol has been defined we can repeatedly execute (i.e. sample) it in the presence of incoherent noise. Let’s say we are interested in the logical error rates of all 1- and 2-qubit gates and measurements subject to physical errors with physical error rates \\(p_{phy}=10^{-5}, \\dots, 10^{-1}\\), and \\(0.5\\). The corresponding noise model is called E1_1 in qsample. The groups of all 1- and 2-qubit gates are indexed by the key q in E1_1. Other noise models (and their parameters) are described in the documentation.\n\nerr_model = qs.noise.E1_1\nerr_params = {'q': [1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 0.5]}\n\nWe are ready to sample. As our protocol only contains Clifford gates let’s choose the StabilizerSimulator, as well as the PlotStats callback for plotting the resulting logical error rate as function of our chosen \\(p_{phy}\\). For now, let’s use our inefficient sampler, DirectSampler, which executes n_shots naive Monte Carlo samples at each physical error rate.\n\nsam = qs.DirectSampler(protocol=tele_proto, simulator=qs.StabilizerSimulator, err_model=err_model, err_params=err_params)\nsam.run(n_shots=20000, callbacks=[qs.callbacks.PlotStats()])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice, that at low error rates DirectSampler performs badly, i.e. the error bars become very large, as most of the time the protocol is executed error free and, consequently, logical errors are measured infrequently. In this regime it is much more efficient to use an importance sampling strategy to avoid fault-free protocol execution and instead put more emphasis on execution with at least one physical error, i.e. fault, happening. This approach is implemented in the SubsetSampler class. We only need to specify two additional parameters: p_max which specifies the \\(p_{phy}\\) at which sampling takes place, and L, the length of the longest possible fault-free path. We choose the parameter p_max experimentally by repeated sampling and observing which subsets have the largest impact on the failure rate. We always choose a value such that the subset occurence probability has an exponentially falling shape. Below we see that for the teleportation circuit p_max-values of 0.01 and 0.1 are still okay, while 0.3 could be problematic. For more information refer to the linked publication.\n\nfor p_phy in [0.01, 0.1, 0.3]:\n    Aws = qs.math.subset_probs(teleport, err_model(), p_phy)\n    plt.figure()\n    plt.title(\"Subset occurence prob. $A_w$ at $p_{phy}$=%.2f\" % p_phy)\n    plt.bar(list(map(str,Aws.keys())), Aws.values())\n    plt.ylabel(\"$A_w$\")\n    plt.xlabel(\"Subsets\")\n\n\n\n\n\n\n\n\n\n\nLet’s choose a \\(p_{max}=0.1\\) for the same error model as before and start sampling. (Note the significant difference in the number of samples).\n\nss_sam = qs.SubsetSampler(protocol=tele_proto, simulator=qs.StabilizerSimulator,  p_max={'q': 0.1}, err_model=err_model, err_params=err_params, L=3)\nss_sam.run(1000, callbacks=[qs.callbacks.PlotStats()])\n\n\n\n\n\n\n\nThe sampling results are internally stored by the SubsetSampler in a Tree data structure. In the tree we can also see why we chose L=3, as there are three circuits in the fault-free path sequence.\n\nss_sam.tree.draw(verbose=True)\n\n\n\n\nWe see that only the teleportation protocol has fault weight subsets, while the meas and COR circuits are noise-free (i.e. they only have the 0-subset). The leaf nodes FAIL and None represent logical failure and successful teleportation events, respectively. \\(\\delta\\) represents the missing subsets which have not been sampled and which result in the upper bound on the failure rate.\nFinally, let’s compare the results of DirectSampler and SubsetSampler.\n\np_L_low, std_low, p_L_up, std_up = ss_sam.stats()\np_L, std = sam.stats()\n\nsample_range = err_params['q']\nplt.errorbar(sample_range, p_L, fmt='--', c=\"black\", yerr=std, label=\"Direct MC\")\nplt.loglog(sample_range, p_L_low, label='SS low')\nplt.fill_between(sample_range, p_L_low - std_low, p_L_low + std_low, alpha=0.2)\nplt.loglog(sample_range, p_L_up, label='SS low')\nplt.fill_between(sample_range, p_L_up - std_up, p_L_up + std_up, alpha=0.2)\nplt.plot(sample_range, sample_range,'k:', alpha=0.5)\nplt.xlabel('$p_{phy}$(q)')\nplt.ylabel('$p_L$')\nplt.legend();"
  },
  {
    "objectID": "index.html#more-things-to-explore",
    "href": "index.html#more-things-to-explore",
    "title": "qsample",
    "section": "More things to explore",
    "text": "More things to explore\n\nqsample.examples shows more examples of protocol and protocol samplings.\nqsample.noise defines more complex error models, as well as a superclass ErrorModel which can be used to define custom error models.\nqsample.callbacks defines more callbacks, as well as the superclass Callback which allows for the implementation of custom callbacks."
  },
  {
    "objectID": "index.html#contribute",
    "href": "index.html#contribute",
    "title": "qsample",
    "section": "Contribute",
    "text": "Contribute\n\nFeel free to submit your feature request via github issues"
  },
  {
    "objectID": "index.html#cite-as",
    "href": "index.html#cite-as",
    "title": "qsample",
    "section": "Cite as",
    "text": "Cite as\n@misc{qsample,\n    author = {Winter, Don and Heu{\\ss}en, Sascha},\n    title = {qsample},\n    year = {2023},\n    publisher = {GitHub},\n    journal = {GitHub repository},\n    howpublished = {\\url{https://github.com/dpwinter/qsample}}\n}"
  },
  {
    "objectID": "index.html#team",
    "href": "index.html#team",
    "title": "qsample",
    "section": "Team",
    "text": "Team\nqsample was developed by Don Winter in collaboration with Sascha Heußen under supervision of Manuel Rispler and Markus Müller."
  },
  {
    "objectID": "sampler.subset.html",
    "href": "sampler.subset.html",
    "title": "Subset Sampler",
    "section": "",
    "text": "/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section References\n  else: warn(msg)\n/home/dw/.local/lib/python3.10/site-packages/fastcore/docscrape.py:225: UserWarning: Unknown section Attributes\n  else: warn(msg)\n\nsource\n\nSubsetSampler\n\n SubsetSampler (protocol, simulator, p_max, err_model, err_params=None,\n                L=None)\n\nClass to represent subset sampler"
  }
]