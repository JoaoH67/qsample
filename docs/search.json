[
  {
    "objectID": "circuit.html",
    "href": "circuit.html",
    "title": "Circuit",
    "section": "",
    "text": "source\n\nunpack\n\n unpack (seq)\n\nGenerator for all qubits defined in a circuit or tick\n\nsource\n\n\nCircuit\n\n Circuit (ticks=None, noisy=True, ff_det=False)\n\nRepresentation of a quantum circuit"
  },
  {
    "objectID": "sim.statevector.html",
    "href": "sim.statevector.html",
    "title": "Statevector Simulator",
    "section": "",
    "text": "source\n\nMeasureResult\n\n MeasureResult (value:bool)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nStatevectorSimulator\n\n StatevectorSimulator (num_qubits)\n\nSimulator mixin for running quantum circuits"
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "qsample",
    "section": "",
    "text": "Before anything else, please install the git hooks that run automatic scripts during each commit and merge to strip the notebooks of superfluous metadata (and avoid merge conflicts). After cloning the repository, run the following command inside it:\nnbdev_install_git_hooks\n\n\n\n\nEnsure the bug was not already reported by searching on GitHub under Issues.\nIf you’re unable to find an open issue addressing the problem, open a new one. Be sure to include a title and clear description, as much relevant information as possible, and a code sample or an executable test case demonstrating the expected behavior that is not occurring.\nBe sure to add the complete error messages.\n\n\n\n\nOpen a new GitHub pull request with the patch.\nEnsure that your PR includes a test that fails without your patch, and pass with it.\nEnsure the PR description clearly describes the problem and solution. Include the relevant issue number if applicable.\n\n\n\n\n\n\nKeep each PR focused. While it’s more convenient, do not combine several unrelated fixes together. Create as many branches as needing to keep each PR focused.\nDo not mix style changes/fixes with “functional” changes. It’s very difficult to review such PRs and it most likely get rejected.\nDo not add/remove vertical whitespace. Preserve the original style of the file you edit as much as you can.\nDo not turn an already submitted PR into your development playground. If after you submitted PR, you discovered that more work is needed - close the PR, do the required work and then submit a new PR. Otherwise each of your commits requires attention from maintainers of the project.\nIf, however, you submitted a PR and received a request for changes, you should proceed with commits inside that PR, so that the maintainer can see the incremental fixes and won’t need to review the whole PR again. In the exception case where you realize it’ll take many many commits to complete the requests, then it’s probably best to close the PR, do the work and then submit it again. Use common sense where you’d choose one way over another.\n\n\n\n\n\nDocs are automatically created from the notebooks in the nbs folder."
  },
  {
    "objectID": "sim.mixin.html",
    "href": "sim.mixin.html",
    "title": "Simulator Mixin",
    "section": "",
    "text": "source\n\nCircuitRunnerMixin\n\n CircuitRunnerMixin ()\n\nSimulator mixin for running quantum circuits"
  },
  {
    "objectID": "sampler.tree.html",
    "href": "sampler.tree.html",
    "title": "Count Tree",
    "section": "",
    "text": "This data structure is based on the Python package anytree (https://github.com/c0fec0de/anytree) which has been extended by the classes Constant, Variable and CountTree.\n\nsource\n\nConstant\n\n Constant (name, parent=None, cid=None, counts=0, is_deterministic=False,\n           **kwargs)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nVariable\n\n Variable (name, parent=None, counts=0, marked=False, **kwargs)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nNode\n\n Node (name, parent=None, children=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nCountTree\n\n CountTree (constants=None, min_path_weight=1)\n\nInitialize self. See help(type(self)) for accurate signature."
  },
  {
    "objectID": "protocol.html",
    "href": "protocol.html",
    "title": "Protocol",
    "section": "",
    "text": "source\n\nProtocol\n\n Protocol (fault_tolerant=False, *args, **kwargs)\n\nRepresentation of a Quantum protocol\n\nfrom qsample.circuit import Circuit\n\n\nghz = Circuit([ {\"init\": {0,1,2,3,4}},\n                {\"H\": {0}},\n                {\"CNOT\": {(0,1)}},\n                {\"CNOT\": {(1,2)}},\n                {\"CNOT\": {(2,3)}},\n                {\"CNOT\": {(3,4)}},\n                {\"CNOT\": {(0,4)}},\n                {\"measure\": {4}}   ], ff_det=True)\n\ndef gen_ghz3():\n    \n    def repeat(m):\n        return len(m) < 3 and m[-1] == 1\n\n    def logErr(m):\n        return len(m) >= 3 and m == [1,1,1]\n\n    functions = {'logErr': logErr, 'repeat': repeat}\n\n    ghz3 = Protocol()\n    ghz3._check_fns.update(functions)\n    ghz3._ft = True\n    \n    ghz3.add_nodes_from(['ghz'], circuits=[ghz])\n    \n    ghz3.add_edge('START', 'ghz', check='True')\n    ghz3.add_edge('ghz', 'ghz', check='repeat(ghz)')\n    ghz3.add_edge('ghz', 'FAIL', check='logErr(ghz)')\n    \n    return ghz3\nghz3 = gen_ghz3()\nghz3.draw()"
  },
  {
    "objectID": "noise.html",
    "href": "noise.html",
    "title": "Noise / Error models",
    "section": "",
    "text": "Some common error sets\n\nsource\n\nErrorModel\n\n ErrorModel ()\n\nRepresentation of an incoherent error model.\n\nsource\n\n\nE0\n\n E0 ()\n\nNo-Error error model\n\nsource\n\n\nE1\n\n E1 ()\n\nOne prob/weight for all 1- and 2-qubit gates\n\nsource\n\n\nE2\n\n E2 ()\n\nIndividual errors on 1-qubit and 2-qubit gates.\n\nsource\n\n\nE3\n\n E3 ()\n\nErrors on all gates individual + idle.\n\nsource\n\n\nE3_1\n\n E3_1 ()\n\nLike E3, but idle locations split in two subsets.\n\nsource\n\n\nInnsbruckTrap\n\n InnsbruckTrap ()\n\nExtension of E3_1 adding crosstalk and idlem."
  },
  {
    "objectID": "sim.stabilizer.html",
    "href": "sim.stabilizer.html",
    "title": "CHP Simulator",
    "section": "",
    "text": "source\n\nStabilizerSimulator\n\n StabilizerSimulator (num_qubits)\n\nThe bare minimum needed for the CHP simulation.\nReference: “Improved Simulation of Stabilizer Circuits” Scott Aaronson and Daniel Gottesman https://arxiv.org/abs/quant-ph/0406196\nOriginal author: Craig Gidney https://github.com/Strilanc/python-chp-stabilizer-simulator"
  },
  {
    "objectID": "math.html",
    "href": "math.html",
    "title": "Math",
    "section": "",
    "text": "source\n\ncomb\n\n comb (n, k)\n\nVectorized combination\n\nsource\n\n\nbinom\n\n binom (k, n, p)\n\nVectorized binomial function\n\nsource\n\n\nWilson_var\n\n Wilson_var (p, N, z=1.96)\n\nWilson estimator of binomial variance\n\nsource\n\n\nWald_var\n\n Wald_var (p, N)\n\nWald estimator of binomial variance (known issues, better use Wilson)"
  },
  {
    "objectID": "sampler.direct.html",
    "href": "sampler.direct.html",
    "title": "Direct Monte Carlo sampler",
    "section": "",
    "text": "from qsample.examples import ghz3\nfrom qsample.noise import E1, E2\nfrom qsample.sim.stabilizer import StabilizerSimulator as CHP\nfrom qsample.callbacks import *\n\nfrom ipywidgets import interact\nimport ipywidgets as widgets\n\n\ne = E1\n\nsample_range = np.logspace(-3,0,5)\n\nerr_probs = {\n    # \"q1\": 0,\n    \"q\": sample_range\n}\n\nsam = DirectSampler(ghz3, CHP, err_probs=err_probs, err_model=e)\n\nsam.run(1000, callbacks=[PlotStats()])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef get_tree(i):\n    print(\"p_phy=\", list(sam.trees.keys())[i])\n    return (list(sam.trees.values())[i]).draw()\ninteract(get_tree, i=widgets.IntSlider(min=0, max=len(sam.trees)-1, step=1, value=0));\n\n\n\n\n\nsam.save('./test')\n\n\nsam2 = Sampler.load('./test')\nsam2.run(100)"
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "ghz.draw()\n\n\n\n\n\nghz_stabs.draw(scale=1.2)\n\n\n\n\n\neft.draw(scale=1.5)\n\n\n\n\n\nsz_123.draw()\n\n\n\n\n\nmeas7.draw(scale=1.2)\n\n\n\n\n\nnfs.draw(scale=1)"
  },
  {
    "objectID": "examples.html#ghz-repeat-until-success-protocol",
    "href": "examples.html#ghz-repeat-until-success-protocol",
    "title": "Examples",
    "section": "GHZ repeat until success protocol",
    "text": "GHZ repeat until success protocol\n\nRepeat GHZ preparation circuit for a maximum of 3 times.\nOnly repeat if a measurement yields 1, i.e. the flag has been triggered.\nIf we measure in all 3 runs three times 1, count a logical failure.\nIn all other cases the protocol completed without logical failure.\n\n\nghz3.draw(figsize=(6,6))"
  },
  {
    "objectID": "examples.html#ghz-stabilizer-measurement",
    "href": "examples.html#ghz-stabilizer-measurement",
    "title": "Examples",
    "section": "GHZ stabilizer measurement",
    "text": "GHZ stabilizer measurement\n\nPrepare GHZ state with flag measurement 0. (If 1 is measured repeat preparation as often as necessary)\nReset ancilla and measure the stabilizers of the GHZ state (without noise). The stabilizers are:\n\nOne XXXX stab\nand three ZZ stabs\n\nUse syndrom from stabilizer measurements to lookup and perform the correction.\nMeasure stabilizers again.\nNow we have a logical failure if this measurement gives us any syndrome, i.e. if the measurement is anything other than four 0s.\n\n\nghz_stab.draw(figsize=(6,6), legend=True)"
  },
  {
    "objectID": "examples.html#fault-tolerant-color-code-flag-protocol",
    "href": "examples.html#fault-tolerant-color-code-flag-protocol",
    "title": "Examples",
    "section": "Fault-tolerant color code flag protocol",
    "text": "Fault-tolerant color code flag protocol\n\n…\n\n\nftsteane.draw(figsize=(8,6), label_offset=(0,0.15))"
  },
  {
    "objectID": "examples.html#det.-steane-logical-0-preparation-protocol",
    "href": "examples.html#det.-steane-logical-0-preparation-protocol",
    "title": "Examples",
    "section": "Det. Steane logical 0 preparation protocol",
    "text": "Det. Steane logical 0 preparation protocol\n\nsteane0.draw(figsize=(6,6), legend=True)"
  },
  {
    "objectID": "examples.html#flag-stabilizer-protocol",
    "href": "examples.html#flag-stabilizer-protocol",
    "title": "Examples",
    "section": "Flag stabilizer protocol",
    "text": "Flag stabilizer protocol\n\n…\n\n\nflagstab.draw(legend=True, figsize=(15,5))"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "qsample",
    "section": "",
    "text": "We are currently in the process to reclaim the name from PyPI, s.t. this package can be installed directly via pip.\nHowever, for now you need to do the following steps:\n1. Clone the repository to your computer.\n2. cd into it.\n3. Execute python setup.py install."
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "qsample",
    "section": "Prerequisites",
    "text": "Prerequisites\nBesides the required python libraries which will be downloaded automatically when you install via pip, some functions of qsample have other non-python dependencies: * All draw() functionality was designed for usage in Jupyter. Some features might not be available when executing directly in the interpreter. * Additionally, the Circuit.draw() function uses the package latextools which is turn requires the pdflatex compiler."
  },
  {
    "objectID": "index.html#when-to-use",
    "href": "index.html#when-to-use",
    "title": "qsample",
    "section": "When to use",
    "text": "When to use\nqsam offers efficient and fast estimation of logical failure rates of quantum error correction protocols when the fidelity of physical operations in the quantum circuits is high, such as in expertimental implementations today.\nThis package is for you if you want to * model circuit-level incoherent Pauli noise (we don’t do coherent noise here, neither are our auxiliary qubits modelled as ideal) * with high fidelity physical operations aka low physical error rates * for a QEC protocol that consists of execution of one or more quantum circuits with in-sequence measurements and feed-forward of measurement information * over a specific range of varying physical error rates\nIt currently offers to * build quantum circuits from the standard quantum gates: H, X, Z, CNOT * run stabilizer simulations with a standard CHP backend * model multiparameter noise with distinct error rates for single- and two-qubit gates: p1, p2 * estimate logical failure rates until uncertainty is lower than a given target confidence interval * choose direct Monte Carlo or Subset Sampling as sampling method\nBackground information:\nThe predominant method to model incoherent Pauli noise in quantum circuits is direct Monte Carlo (MC) sampling. MC is very inefficient for low physical error rates since most of the time no actual fault event is realized in simulation. Subset sampling circumvents this issue. With this method, presented in , fault events are categorized into distinct subsets which contribute to a polynomial sum expansion of the logical failure rate. In subset sampling, only the subsets that contribute most to the logical failure rate are actually estimated via sampling – rendering it an importance sampling technique. Both the sampling variance and the uncertainty from ignored, i.e. non-sampled, subsets stay well-defined and can be held small throughout the sampling procedure."
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "qsample",
    "section": "Getting started",
    "text": "Getting started\n\nCircuits\nTo get started, we first need to define one or more circuits, which is easily done in qsam. Below we create a circuit that prepares the 4-qubit GHZ state \\(|\\text{GHZ}\\rangle=\\frac{1}{\\sqrt{2}}(|0000\\rangle+|1111\\rangle)\\).\n\nfrom qsample.circuit import Circuit\n\nghz = Circuit([ {\"init\": {0,1,2,3,4}},\n                {\"H\": {0}},\n                {\"CNOT\": {(0,1)}},\n                {\"CNOT\": {(1,2)}},\n                {\"CNOT\": {(2,3)}},\n                {\"CNOT\": {(3,4)}},\n                {\"CNOT\": {(0,4)}},\n                {\"measure\": {4}}], ff_det=True)\n\nThe keyword ff_detis set to True to indicate that the circuit will yield a deterministic outcome when ran fault-free. It is important for the calculation of uncertainties. This need not be the case, e.g. for circuits that measure stabilizers on unencoded states and thus yield random measurement results. An example of a fault-tolerant measurement circuit for the Steane code stabilizer \\(Z_0Z_1Z_3Z_6\\) is given below. The default value of ff_detis False.\n\nsz_123 = Circuit([{\"init\": {8}},\n                {\"CNOT\": {(0,8)}},\n                {\"CNOT\": {(1,8)}},\n                {\"CNOT\": {(3,8)}},\n                {\"CNOT\": {(6,8)}},\n                {\"measure\": {8}}])\n\n\n# add ghz run, explain all arguments and comparison of mc and ss\n\n\n# also output errors, esp. show that delta only becomes smaller\n\n\n\nProtocols\nFrom the single ghz-circuit given above, we may construct a simple toy-protocol to demonstrate essential features of qsam. The protocol is that, whenever the circuit measurement is \\(-1\\), we shall repeat the preparation circuit since the fifth qubit indicates preparation of an erroneous state. When the measurement is \\(+1\\) the state is prepared correctly. If there is still no \\(+1\\) after two preparation attempts, we count the protocol run as a logical failure. These conditions are defined in the following functions:\n\nfrom qsample.protocol import Protocol\n\ndef repeat(m):\n    return len(m) < 2 and m[-1] == 1\n    \ndef logErr(m):\n    return len(m) >= 2 and m[-1] == 1 and m[-2] == 1\n\nfunctions = {'logErr': logErr, 'repeat': repeat}\n\nThe protocol is now defined as a graph, where nodes are circuits and edges between the nodes are labelled with transition conditions between the circuits. Terminating a protocol with success (instead of fail) will not be shown explicitly by the protocol graph. The check argument takes a function, which returns a boolean, to evaluate a transition based on the sequence of measurement results stored in the node as a list (ghz in this example).\n\ng = Protocol(fault_tolerant=True)\ng._check_fns.update(functions)\ng.add_nodes_from(['ghz'], circuits=[ghz])\n\ng.add_edge('START', 'ghz', check='True')\n\ng.add_edge('ghz', 'ghz', check='repeat(ghz)')\ng.add_edge('ghz', 'FAIL', check='logErr(ghz)')\n\ng.draw(figsize=(6,5))\n\n\n\n\nWe may now specify our error parameters, i.e. the range over which we wish to scale the physical error rates. Let’s start with a single parameter \\(p\\) for both single- and two-qubit-gates. Here, we are exploring logical failure rates for physical error rates \\(p \\in [0.00001, 0.1]\\).\n\nscale = np.logspace(-5,-1,5)\nerr_probs = {'q': scale}\n\nWe initialize a new direct Monte Carlo sampler and set up a depolarizing noise model.\n\nfrom qsample.sim.stabilizer import StabilizerSimulator as CHP\nfrom qsample.sampler.direct import DirectSampler\nfrom qsample.noise import E1\nimport qsample.callbacks as cb\n\nd_sam = DirectSampler(protocol=g, simulator=CHP, err_model=E1, err_probs=err_probs)\n\nIts run function takes the maximum number of samples and/or user specified callback functions. Here we use for example the RelStdTarget callback to specify a maximum error of 10% (which is actually the default value) or 50000 samples at max. The logical failure rate estimator and its uncertainty are then plotted in the range defined by scale by the PlotStats callback from the relevant information (counts and fail_counts) which are stored directly in the Sampler object.\n\ncallbacks = [\n    cb.RelStdTarget(target=0.1),\n    cb.PlotStats()\n]\n\nd_sam.run(n_samples=5000, callbacks=callbacks)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe sampler instance allows to print the logical failure rate estimator and its sampling and cutoff error over the sampled range.\n\np_L, std = d_sam.stats()\nprint(p_L)\nprint(std)\n\n[0.0, 0.0, 0.0002, 0.0008, 0.0426]\n[0.00038387 0.00038387 0.00054841 0.00087211 0.00560673]\n\n\n\nfrom ipywidgets import interact\nimport ipywidgets as widgets\n\ndef get_tree(i):\n    print(\"p_phy=\", list(d_sam.trees.keys())[i])\n    return (list(d_sam.trees.values())[i]).draw()\n\ninteract(get_tree, i=widgets.IntSlider(min=0, max=len(d_sam.trees)-1, step=1, value=0));\n\n\n\n\nWe can observe in the statistics of the direct MC Sampler that it does not even record logical failures with moderately low \\(p\\) with the given number of samples. The Subset Sampler fixes this problem.\nAdditionally to just sampling the logical failure rate we can specify a variety of callbacks to track desired quantities of the sampling process. A comprehensive list is given in directory. Below we plot, for example, the logical failure rate at p = p_max = 0.01 and its uncertainty as a function of the number of samples run.\n\nfrom qsample.sampler.subset import SubsetSampler\n\ns_sam = SubsetSampler(protocol=g, simulator=CHP, pmax={'q': 0.1}, err_model=E1, err_probs=err_probs)\n\n\ncallbacks = [\n    cb.StatsPerSample()\n]\ns_sam.run(n_samples=1000, callbacks=callbacks)\n\n\n\n\n\n\n\nThe Sampler instance contains a Tree structure that we can investigate manually with sb_sam.tree, or plot as image.\n\ns_sam.tree.draw()\n\n\n\n\nFrom plotting the MC and SS results together we can see that they produce the same results in some intermediate regime of \\(p\\). Subset Sampling achieves tight bounds on the logical failure rate for low \\(p\\) where the uncertainty for MC is large. Vice versa, Subset Sampling becomes inefficient if the cutoff error from only sampling a few subsets becomes large for larger \\(p\\). Here though, MC is efficient.\n\nimport matplotlib.pyplot as plt\n\np_L_low, ss_std, delta, delta_ss = s_sam.stats()\np_L, std,  = d_sam.stats()\n\nplt.errorbar(scale, p_L, fmt='--', c=\"black\", yerr=std, label=\"Direct MC\")\n\nplt.plot(scale, p_L_low, label=\"SS low\")\nplt.fill_between(scale, p_L_low-ss_std, p_L_low+delta+ss_std, alpha=0.2)\n\nplt.plot(scale, p_L_low+delta, label=\"SS up\")\nplt.fill_between(scale, p_L_low-ss_std, p_L_low+delta+ss_std, alpha=0.2)\n\nplt.plot(scale, scale, 'k:', alpha=0.5)\nplt.xscale('log')\nplt.yscale('log')\nplt.ylabel(r'$p_L$')\nplt.xlabel(r'$\\lambda$ - uniform')\nplt.legend();\n\n\n\n\nWith the already sampled subsets we can also vary the plotted range in retrospect.\n\nadjusted_scale = np.logspace(-3,-1,5)\np_L_low, ss_std, delta, _ = s_sam.stats({'q': adjusted_scale})\n\n(Below we also show the MC output in the adjusted range but for the direct Sampler we cannot modify the range in that way)\n\nplt.errorbar(scale[-2:], p_L[-2:], fmt='--', c=\"black\", yerr=std[-2:], label=\"Direct MC\")\n\nplt.plot(adjusted_scale, p_L_low, label=\"SS low\")\nplt.fill_between(adjusted_scale, p_L_low-ss_std, p_L_low+delta+ss_std, alpha=0.2)\n\nplt.plot(adjusted_scale, p_L_low+delta, label=\"SS up\")\nplt.fill_between(adjusted_scale, p_L_low-ss_std, p_L_low+delta+ss_std, alpha=0.2)\n\nplt.xscale('log')\nplt.yscale('log')\nplt.ylabel(r'$p_L$')\nplt.xlabel(r'$\\lambda$ - uniform')\nplt.legend();\n\n\n\n\nWe may add 100 more samples to the already existing 500 samples…\n\ns_sam.run(100, callbacks=callbacks)\n\n\n\n\n\n\n\n… or pickle it for later use.\n\nprint(s_sam.tree)\n\nghz (1100, 0.00e+00)\n├── (0,) (1, 1.57e-01)\n│   └── None (1/1)\n├── (1,) (841, 1.11e-03)\n│   ├── None (482/841)\n│   └── ghz (359/841)\n│       ├── (2,) (81, 1.13e-02)\n│       │   ├── FAIL (43/81)\n│       │   └── None (38/81)\n│       ├── (1,) (266, 3.48e-03)\n│       │   ├── None (153/266)\n│       │   └── FAIL (113/266)\n│       ├── (0,) (1, 1.57e-01)\n│       │   └── None (1/1)\n│       └── (3,) (11, 6.43e-02)\n│           ├── FAIL (5/11)\n│           └── None (6/11)\n├── (3,) (26, 3.15e-02)\n│   ├── None (11/26)\n│   └── ghz (15/26)\n│       ├── (2,) (3, 1.34e-01)\n│       │   ├── None (1/3)\n│       │   └── FAIL (2/3)\n│       ├── (0,) (1, 1.57e-01)\n│       │   └── None (1/1)\n│       └── (1,) (11, 6.43e-02)\n│           ├── FAIL (5/11)\n│           └── None (6/11)\n├── (2,) (228, 4.14e-03)\n│   ├── None (114/228)\n│   └── ghz (114/228)\n│       ├── (0,) (1, 1.57e-01)\n│       │   └── None (1/1)\n│       ├── (1,) (86, 1.01e-02)\n│       │   ├── FAIL (33/86)\n│       │   └── None (53/86)\n│       ├── (3,) (2, 1.64e-01)\n│       │   ├── FAIL (1/2)\n│       │   └── None (1/2)\n│       └── (2,) (25, 3.21e-02)\n│           ├── None (15/25)\n│           └── FAIL (10/25)\n└── (4,) (4, 1.07e-01)\n    ├── None (3/4)\n    └── ghz (1/4)\n        └── (0,) (1, 1.57e-01)\n            └── None (1/1)\n\n\n\ns_sam.save('ghz_rep')\n\n\ns_sam2 = SubsetSampler.load('ghz_rep')\nprint(s_sam2.tree)\n\nghz (1100, 0.00e+00)\n├── (0,) (1, 1.57e-01)\n│   └── None (1/1)\n├── (1,) (841, 1.11e-03)\n│   ├── None (482/841)\n│   └── ghz (359/841)\n│       ├── (2,) (81, 1.13e-02)\n│       │   ├── FAIL (43/81)\n│       │   └── None (38/81)\n│       ├── (1,) (266, 3.48e-03)\n│       │   ├── None (153/266)\n│       │   └── FAIL (113/266)\n│       ├── (0,) (1, 1.57e-01)\n│       │   └── None (1/1)\n│       └── (3,) (11, 6.43e-02)\n│           ├── FAIL (5/11)\n│           └── None (6/11)\n├── (3,) (26, 3.15e-02)\n│   ├── None (11/26)\n│   └── ghz (15/26)\n│       ├── (2,) (3, 1.34e-01)\n│       │   ├── None (1/3)\n│       │   └── FAIL (2/3)\n│       ├── (0,) (1, 1.57e-01)\n│       │   └── None (1/1)\n│       └── (1,) (11, 6.43e-02)\n│           ├── FAIL (5/11)\n│           └── None (6/11)\n├── (2,) (228, 4.14e-03)\n│   ├── None (114/228)\n│   └── ghz (114/228)\n│       ├── (0,) (1, 1.57e-01)\n│       │   └── None (1/1)\n│       ├── (1,) (86, 1.01e-02)\n│       │   ├── FAIL (33/86)\n│       │   └── None (53/86)\n│       ├── (3,) (2, 1.64e-01)\n│       │   ├── FAIL (1/2)\n│       │   └── None (1/2)\n│       └── (2,) (25, 3.21e-02)\n│           ├── None (15/25)\n│           └── FAIL (10/25)\n└── (4,) (4, 1.07e-01)\n    ├── None (3/4)\n    └── ghz (1/4)\n        └── (0,) (1, 1.57e-01)\n            └── None (1/1)"
  },
  {
    "objectID": "index.html#real-examples",
    "href": "index.html#real-examples",
    "title": "qsample",
    "section": "Real examples",
    "text": "Real examples\nFor more complicated protocols, we might want to receive more feedback from what the sampler is actually doing. Using the verbose keyword, we can print the actual circuit sequences realized through out the sampling procedure and watch which intermediate measurement results lead to different circuit branchings.\nTo illustrate this, we give the example of first preparing the logical zero state of the Steane code. A flag qubit verifies correct preparation in the first circuit. The second circuit is only run, if the flag is triggered. It restores the correct state in a fault-tolerant way from the state after the first circuit marked as faulty by the flag.\n\neft = Circuit([ {\"init\": {0,1,2,4,3,5,6,7}},\n                {\"H\": {0,1,3}},\n                {\"CNOT\": {(0,4)}},\n                {\"CNOT\": {(1,2)}},\n                {\"CNOT\": {(3,5)}},\n                {\"CNOT\": {(0,6)}},\n                {\"CNOT\": {(3,4)}},\n                {\"CNOT\": {(1,5)}},\n                {\"CNOT\": {(0,2)}},\n                {\"CNOT\": {(5,6)}},\n                {\"CNOT\": {(4,7)}},\n                {\"CNOT\": {(2,7)}},\n                {\"CNOT\": {(5,7)}},\n                {\"measure\": {7}} ], ff_det=True)\n\nsz_123 = Circuit([{\"init\": {8}},\n                {\"CNOT\": {(0,8)}},\n                {\"CNOT\": {(1,8)}},\n                {\"CNOT\": {(3,8)}},\n                {\"CNOT\": {(6,8)}},\n                {\"measure\": {8}}])\n\nmeas = Circuit([ {\"measure\": {0,1,2,3,4,5,6}} ])\n\nk1 = 0b0001111\nk2 = 0b1010101\nk3 = 0b0110011\nk12 = k1 ^ k2\nk23 = k2 ^ k3\nk13 = k1 ^ k3\nk123 = k12 ^ k3\nstabilizerGenerators = [k1, k2, k3]\nstabilizerSet = [0, k1, k2, k3, k12, k23, k13, k123]\n\ndef hamming2(x, y):\n    count, z = 0, x ^ y\n    while z:\n        count += 1\n        z &= z - 1\n    return count\n\n\ndef logErr(out):\n    if min([hamming2(out, i) for i in stabilizerSet]) > 1:\n        return True\n    else:\n        return False\n        \ndef flagged_z_look_up_table_1(z):\n    if z:\n        return Circuit([{'X': {6}}], noisy=False)\n    else:\n        return Circuit(noisy=False)\n\nfunctions = {\"logErr\": logErr, \"lut\": flagged_z_look_up_table_1}\n\ninit = Protocol(fault_tolerant=True)\ninit._check_fns.update(functions)\n\ninit.add_nodes_from(['ENC', 'SZ', 'meas'], circuits=[eft, sz_123, meas])\ninit.add_node('X_COR', circuit=Circuit(noisy=False))\n\ninit.add_edge('START', 'ENC', check='True')\n\ninit.add_edge('ENC', 'meas', check='ENC[-1]==0')\n\ninit.add_edge('ENC', 'SZ', check='ENC[-1]==1')\ninit.add_edge('SZ', 'X_COR', check='lut(SZ[-1])')\n\ninit.add_edge('X_COR', 'meas', check='True')\n\ninit.add_edge('meas', 'FAIL', check='logErr(meas[-1])')\n\ninit.draw(figsize=(6,8), legend=True)\n\n\n\n\nThe protocol contains a recovery operation which is applied conditioned on the stabilizer measurement result being \\(-1\\). The check function, which we previously introduced to only take boolean values, in this case actually accepts a circuit which corresponds to the recovery operation. To avoid also placing fault operators on this circuit, we use the keyword noisy and set it to False (this can be used for any circuit). The recovery operation is the return value of the look up table function we define above.\nWe may choose more realistic error rates for single and two qubit gates.\n\nerr_probs = {'q1': 0.01 * scale, 'q2': 0.1 * scale}\n\nLet’s first run 10 samples to see what the protocol does. For this means we can use the VerboseCircuitExec callback:\n\nfrom qsample.noise import E2\n\nsb_sam = SubsetSampler(init, CHP, pmax={'q1': 0.01, 'q2': 0.1}, err_probs=err_probs, err_model=E2)\n\ncallbacks = [\n    cb.VerboseCircuitExec()\n]\nsb_sam.run(10, callbacks=callbacks)\n\n\n\n\nENC -> Faults: [] -> Msmt: 0\nmeas -> Faults: [] -> Msmt: 1100110\nNone\nENC -> Faults: [(9, {'Y': {5, 6}}), (10, {'Z': {4}, 'X': {7}})] -> Msmt: 0\nmeas -> Faults: [] -> Msmt: 0001100\nFAIL\nENC -> Faults: [(2, {'X': {0}})] -> Msmt: 1\nSZ -> Faults: [(1, {'Z': {0}})] -> Msmt: 0\nNone\nENC -> Faults: [(12, {'Y': {5, 7}})] -> Msmt: 1\nSZ -> Faults: [(2, {'Z': {1}, 'X': {8}})] -> Msmt: 1\nX_COR: [(0, {'X': {6}})]\nmeas -> Faults: [] -> Msmt: 0110000\nFAIL\nENC -> Faults: [(2, {'Z': {0}})] -> Msmt: 0\nmeas -> Faults: [] -> Msmt: 0110011\nNone\nENC -> Faults: [(5, {'Z': {0}, 'X': {6}}), (6, {'Y': {3, 4}}), (7, {'X': {5}})] -> Msmt: 0\nmeas -> Faults: [] -> Msmt: 0001110\nNone\nENC -> Faults: [(4, {'Z': {3}, 'Y': {5}}), (6, {'X': {3, 4}}), (9, {'Z': {5}})] -> Msmt: 0\nmeas -> Faults: [] -> Msmt: 1101001\nNone\nENC -> Faults: [(2, {'Y': {0}, 'Z': {4}}), (8, {'X': {0, 2}})] -> Msmt: 0\nmeas -> Faults: [] -> Msmt: 1010100\nNone\nENC -> Faults: [(2, {'Y': {0}, 'Z': {4}})] -> Msmt: 1\nSZ -> Faults: [] -> Msmt: 0\nNone\nENC -> Faults: [(10, {'Y': {4}})] -> Msmt: 0\nmeas -> Faults: [] -> Msmt: 0110111\nNone\n\n\nWhen the flag is triggered, measurement of \\(Z_0Z_1Z_3Z_6\\) follows.\nWe can now go on and sample in a regime virtually inaccessible to direct MC until our target uncertainty of – let say 5% – is reached.\n\nerr_probs = {'q1': 0.0001 * scale, 'q2': 0.001 * scale}\n\n\nsb_sam = SubsetSampler(init, CHP, pmax={'q1': 0.01, 'q2': 0.1}, err_probs=err_probs, err_model=E2)\n\ncallbacks = [\n    cb.RelStdTarget(target=0.01),\n    cb.StatsPerSample(),\n    cb.PlotStats()\n]\n\nsb_sam.run(1_000, callbacks=callbacks)\n\n\n\n\n\n\n\n\n\n\n\nsb_sam.tree.draw()\n\n\n\n\nMore elaborate examples are given in directory."
  },
  {
    "objectID": "index.html#contribute",
    "href": "index.html#contribute",
    "title": "qsample",
    "section": "Contribute",
    "text": "Contribute"
  },
  {
    "objectID": "index.html#team",
    "href": "index.html#team",
    "title": "qsample",
    "section": "Team",
    "text": "Team\nqsam was developed by Don Winter based on and in collaboration with Sascha Heußen under supervision of Prof. Dr. Markus Müller."
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "qsample",
    "section": "License",
    "text": "License"
  },
  {
    "objectID": "sampler.base.html",
    "href": "sampler.base.html",
    "title": "Sampler base class",
    "section": "",
    "text": "Definitions: * A circuit location (cloc) is a tuple (tick_index,qubit(s)) which specifies a location in a circuit. In the simplest case this tuple can be understood as a Euclidean coordinate in tick-qubit-space, for example (1,2) for a circuit element at tick 1 on qubit 2, for example a single-qubit gate. However, the second entry in the tuple can also be a tuple of qubits, i.e. (tick_index, (qubitA, qubitB)), for example (1,(2,3)) for a 2-qubit gate in tick 1 from qubit 2 (control) to qubit 3 (target). It is important that (1,(2,3)) \\(\\neq\\) (1,(3,2)) \\(\\neq\\) (1,2)+(1,3). * Common circuit locations can be grouped into a location group (locgrp), for example the set of all 1-qubit gate locations or the set of all idle qubits or all neighboring qubits of 1-qubit gates. A location group is defined by the error model, which sweeps through a circuit and extracts all elements belonging to a certain group. Note that circuit locations can appear in more than one location group and the union of all location groups must not necessarily give all possible circuit locations. This is for example the case for error models which only define errors on gates but not on idle qubits. * By location group weight (locgrp_wgt) we refer to an integer number specifying the amount of location group elements on which to place faults. Note that the weight only specifies the amount, neither the specific element on which the fault is placed (this will be choosen uniformly random) nor the specific error which will be placed (this will be drawn uniformly random from a set of group errors (locgrp_errsets) defined by the error model). * By location group probability (locgrp_prob) on the other hand, we refer to the probability of placing faults on each element of a group. Thus, during circuit execution it will be decided for each element of a location group if an error is placed based on the group probability. * Both the above can be written as vectors over all location groups an error model specifies. The vector of location group weights (locgrp_wgts) thereby characterizes a so-called fault-weight subset, i.e. a particular amount of faults on each location group defined in an error model. These subsets form the sampling space on which we apply importance sampling during subset sampling. * For subset sampling we analytically calculate the subset occurence probability (Aws) as a function of location group probabilities locgrp_probsfor each location group. As a subset occurence probability results from a binomial distribution binom(locgrp_wts, locgrp_lens, locgrp_probs) we also refer to it as binomial weight of a subset, or simply \\(A_w\\), as this is the symbol used in the paper. * If one of the above quantities is preceeded by a protocol_ we have a dictionary with circuit ids (cids) as keys and the given quantity for a circuit as value. Note that locgrp_probs are defined equally for each circuit in the protocol as those represent physical error rates of a (faulty) device which also won’t be different for different circuits in reality. To sample from more than physical error rate a range locgrp_probs_range can be specified which contains a range of error rates for each location group. * locgrp_wgts_combis are all possible locgrp_wgts vectors up to the total number of elements (locgrp_len) in each location group.\n\nsource\n\nprotocol_subset_occurence\n\n protocol_subset_occurence (protocol_groups, protocol_subsets,\n                            group_probs)\n\n\nsource\n\n\nprotocol_all_subsets\n\n protocol_all_subsets (protocol_groups)\n\n\nsource\n\n\nall_subsets\n\n all_subsets (groups)\n\n\nsource\n\n\nsubset_occurence\n\n subset_occurence (groups, subsets, group_prob_range)\n\n\nsource\n\n\nerr_probs_tomatrix\n\n err_probs_tomatrix (err_probs:dict, groups:list)\n\n\nsource\n\n\ntomatrix\n\n tomatrix (mixed_list)\n\n\nsource\n\n\nSampler\n\n Sampler (protocol, simulator, err_probs={'0': {}}, err_model=None)\n\nInitialize self. See help(type(self)) for accurate signature."
  },
  {
    "objectID": "callbacks.html",
    "href": "callbacks.html",
    "title": "Sampler Callbacks",
    "section": "",
    "text": "source\n\nCallbackList\n\n CallbackList (sampler, callbacks=[])\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nCallback\n\n Callback ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nPlotStats\n\n PlotStats ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nRelStdTarget\n\n RelStdTarget (target=0.1, include_delta=True)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nStatsPerSample\n\n StatsPerSample (log_dir=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nVerboseCircuitExec\n\n VerboseCircuitExec ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nErvPerSample\n\n ErvPerSample (log_dir=None)\n\nInitialize self. See help(type(self)) for accurate signature."
  },
  {
    "objectID": "sampler.subset.html",
    "href": "sampler.subset.html",
    "title": "Subset Monte Carlo sampler",
    "section": "",
    "text": "from qsample.examples import ghz3\nfrom qsample.noise import E3\nimport qsample.callbacks as cb\nfrom qsample import StabilizerSimulator as CHP\nimport numpy as np\n\nsample_range = np.logspace(-3,0,5)\n\nerr_probs = {\n    'q1': 0,\n    'q2': sample_range,\n    'init': sample_range,\n    'meas': sample_range,\n    'idle': 0\n}\npmax = {\n    'q1': 0.1,\n    'q2': 0.1,\n    'init': 0.1,\n    'meas': 0.1,\n    'idle': 0\n}\nsam = SubsetSampler(ghz3, CHP,  pmax=pmax, err_probs=err_probs, err_model=E3)\nsam.run(100, [cb.PlotStats()])"
  }
]