---

title: Sampler base class


keywords: fastai
sidebar: home_sidebar

summary: "Super class for all sampler objects"
description: "Super class for all sampler objects"
nb_path: "06b_sampler.base.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 06b_sampler.base.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Definitions:</p>
<ul>
<li>A <em>circuit location</em> (<code>cloc</code>) is a tuple (tick_index,qubit(s)) which specifies a location in a circuit. In the simplest case this tuple can be understood as a Euclidean coordinate in tick-qubit-space, for example (1,2) for a circuit element at tick 1 on qubit 2, for example a single-qubit gate. However, the second entry in the tuple can also be a tuple of qubits, i.e. (tick_index, (qubitA, qubitB)), for example (1,(2,3)) for a 2-qubit gate in tick 1 from qubit 2 (control) to qubit 3 (target). It is important that (1,(2,3)) $\neq$ (1,(3,2)) $\neq$ (1,2)+(1,3). </li>
<li>Common circuit locations can be grouped into a <em>location group</em> (<code>locgrp</code>), for example the set of all 1-qubit gate locations or the set of all idle qubits or all neighboring qubits of 1-qubit gates. A location group is defined by the error model, which sweeps through a circuit and extracts all elements belonging to a certain group. Note that circuit locations can appear in more than one location group and the union of all location groups must not necessarily give all possible circuit locations. This is for example the case for error models which only define errors on gates but not on idle qubits.</li>
<li>By <em>location group weight</em> (<code>locgrp_wgt</code>) we refer to an integer number specifying the amount of location group elements on which to place faults. Note that the weight only specifies the amount, neither the specific element on which the fault is placed (this will be choosen uniformly random) nor the specific error which will be placed (this will be drawn uniformly random from a set of group errors (<code>locgrp_errsets</code>) defined by the error model).</li>
<li>By <em>location group probability</em> (<code>locgrp_prob</code>) on the other hand, we refer to the probability of placing faults on <strong>each</strong> element of a group. Thus, during circuit execution it will be decided for each element of a location group if an error is placed based on the group probability.</li>
<li>Both the above can be written as vectors over all location groups an error model specifies. The vector of location group weights (<code>locgrp_wgts</code>) thereby characterizes a so-called fault-weight <code>subset</code>, i.e. a particular amount of faults on each location group defined in an error model. These subsets form the sampling space on which we apply importance sampling during subset sampling.</li>
<li>For subset sampling we analytically calculate the <em>subset occurence probability</em> (<code>Aws</code>) as a function of location group probabilities <code>locgrp_probs</code>for each location group. As a subset occurence probability results from a binomial distribution <em>binom(locgrp_wts, locgrp_lens, locgrp_probs)</em> we also refer to it as <em>binomial weight</em> of a subset, or simply $A_w$, as this is the symbol used in the paper.</li>
<li>If one of the above quantities is preceeded by a <code>protocol_</code> we have a dictionary with <em>circuit ids</em> (<code>cids</code>) as keys and the given quantity for a circuit as value. Note that <code>locgrp_probs</code> are defined equally for each circuit in the protocol as those represent physical error rates of a (faulty) device which also won't be different for different circuits in reality. To sample from more than physical error rate a range <code>locgrp_probs_range</code> can be specified which contains a range of error rates for each location group.</li>
<li><a href="/qsam/sampler.base.html#locgrp_wgts_combis"><code>locgrp_wgts_combis</code></a> are all possible <code>locgrp_wgts</code> vectors up to the total number of elements (<code>locgrp_len</code>) in each location group.</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="ranges_from_probs" class="doc_header"><code>ranges_from_probs</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/sampler/base.py#L23" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>ranges_from_probs</code>(<strong><code>locgrp_probs</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="circuit_subset_occurence" class="doc_header"><code>circuit_subset_occurence</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/sampler/base.py#L36" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>circuit_subset_occurence</code>(<strong><code>locgrps</code></strong>:<code>dict</code>, <strong><code>locgrps_wgts_combis</code></strong>:<code>list</code>, <strong><code>locgrp_probs</code></strong>:<code>(dict, list)</code>)</p>
</blockquote>
<p>Return matrix of dims (locgrp_wgts)x(probs_range), i.e. the binomial weights
for each location group weight (rows) and the corresponding physical error rates (columns).</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="protocol_subset_occurence" class="doc_header"><code>protocol_subset_occurence</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/sampler/base.py#L46" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>protocol_subset_occurence</code>(<strong><code>protocol_locgrps</code></strong>:<code>dict</code>, <strong><code>protocol_locgrp_wgts_combis</code></strong>:<code>dict</code>, <strong><code>locgrp_probs</code></strong>:<code>(dict, list)</code>)</p>
</blockquote>
<p>Generate subset occurence probabilities corresponding to each subset weight
combination per circuit location group in <code>locgrp</code> in protocol.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="locgrp_wgts_combis" class="doc_header"><code>locgrp_wgts_combis</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/sampler/base.py#L53" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>locgrp_wgts_combis</code>(<strong><code>locgrps</code></strong>:<code>dict</code>)</p>
</blockquote>
<p>Return list of all possible location group weight vector combinations.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="protocol_locgrp_wgts_combis" class="doc_header"><code>protocol_locgrp_wgts_combis</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/sampler/base.py#L57" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>protocol_locgrp_wgts_combis</code>(<strong><code>protocol_locgrps</code></strong>:<code>dict</code>)</p>
</blockquote>
<p>Generate all possible location group weight vector combinations
for each circuit in a given protocol.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">prob_vecs</span> <span class="o">=</span> <span class="n">ranges_from_probs</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">])</span>
<span class="k">for</span> <span class="n">prob_vec</span> <span class="ow">in</span> <span class="n">prob_vecs</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">prob_vec</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[0.1 0.1]
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)},</span> <span class="s1">&#39;p2&#39;</span><span class="p">:</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))}}}</span>
<span class="n">proto_ws</span> <span class="o">=</span> <span class="n">protocol_locgrp_wgts_combis</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="n">proto_Aws</span> <span class="o">=</span> <span class="n">protocol_subset_occurence</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">proto_ws</span><span class="p">,{</span><span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s1">&#39;p2&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">})</span>

<span class="p">{</span><span class="n">cid</span><span class="p">:</span> <span class="p">{</span><span class="n">w</span><span class="p">:</span> <span class="n">Aw</span> <span class="k">for</span> <span class="n">Aw</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Aws</span><span class="p">,</span><span class="n">ws</span><span class="p">)}</span> <span class="k">for</span> <span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="n">Aws</span><span class="p">),</span> <span class="n">ws</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">proto_Aws</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">proto_ws</span><span class="o">.</span><span class="n">values</span><span class="p">())}</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>{&#39;a&#39;: {(0, 0): (0, 0), (0, 1): (0, 1), (1, 0): (1, 0), (1, 1): (1, 1)}}</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Sampler" class="doc_header"><code>class</code> <code>Sampler</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/sampler/base.py#L64" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Sampler</code>(<strong><code>protocol</code></strong>, <strong><code>simulator</code></strong>, <strong><code>err_model</code></strong>=<em><code>E0</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

</div>


