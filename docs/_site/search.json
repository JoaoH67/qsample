[
  {
    "objectID": "examples/Steane.html",
    "href": "examples/Steane.html",
    "title": "Input = STIM",
    "section": "",
    "text": "import qsample as qs\nimport qiskit\nimport time\nimport stim\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nimport re\nfrom tqdm.notebook import tqdm\nimport random\n\n\neft = qs.Circuit(noisy=True)\nsz_123 = qs.Circuit(noisy=True)\nmeas7 = qs.Circuit(noisy=False)\n\neft.from_stim_circuit(\"\"\"R 0 1 2 3 4 5 6 7\nH 0 1 3\n                        CNOT 0 4\n                        CNOT 1 2\n                        TICK\n                        CNOT 3 5\n                        TICK\n                        CNOT 0 6\n                        TICK\n                        CNOT 3 4\n                        TICK\n                        CNOT 1 5\n                        TICK\n                        CNOT 0 2\n                        TICK\n                        CNOT 5 6\n                        TICK\n                        CNOT 4 7\n                        TICK\n                        CNOT 2 7\n                        TICK\n                        CNOT 5 7\n                        M 7\"\"\")\n\nsz_123.from_stim_circuit(\"\"\"R 8\nCNOT 0 8\n                        TICK\n                        CNOT 1 8\n                        TICK\n                        CNOT 3 8\n                        TICK\n                        CNOT 6 8\n                            M 8\"\"\")\n\nmeas7.from_stim_circuit(\"\"\"M 0 1 2 3 4 5 6\"\"\")\n\n\n\n\n\nk1 = 0b0001111\nk2 = 0b1010101\nk3 = 0b0110011\nk12 = k1 ^ k2\nk23 = k2 ^ k3\nk13 = k1 ^ k3\nk123 = k12 ^ k3\nstabilizerGenerators = [k1, k2, k3]\nstabilizerSet = [0, k1, k2, k3, k12, k23, k13, k123]\n\ndef hamming2(x, y):\n    count, z = 0, x ^ y\n    while z:\n        count += 1\n        z &= z - 1\n    return count\n\nfails = []\ndef logErr(out):\n    global fails\n    c = np.array([hamming2(out, i) for i in stabilizerSet])\n    d = np.flatnonzero(c &lt;= 1)\n    e = np.array([hamming2(out ^ (0b1111111), i) for i in stabilizerSet])\n    f = np.flatnonzero(e &lt;= 1)\n    if len(d) != 0:\n        return False\n    elif len(f) != 0:\n        fails.append(out)\n        return True\n    if len(d) != 0 and len(f) != 0: \n        raise('-!-!-CANNOT BE TRUE-!-!-')\n\ndef flagged_z_look_up_table_1(z):\n    s = [z]\n\n    if s == [1]:\n        return True\n    else: \n        return False\n\nfunctions = {\"logErr\": logErr, \"lut\": flagged_z_look_up_table_1}\n\nsteane0 = qs.Protocol(check_functions=functions, fault_tolerant=True)\n\nsteane0.add_nodes_from(['ENC', 'Z2', 'meas'], circuits=[eft, sz_123, meas7])\nsteane0.add_node('X_COR', circuit=qs.Circuit(noisy=True).from_stim_circuit(\"\"\"X 6\"\"\"))\nsteane0.add_edge('START', 'ENC', check='True')\nsteane0.add_edge('ENC', 'meas', check='ENC[-1]==0')\nsteane0.add_edge('ENC', 'Z2', check='ENC[-1]==1')\nsteane0.add_edge('Z2', 'X_COR', check='lut(Z2[-1])')\nsteane0.add_edge('Z2', 'meas', check='not lut(Z2[-1])')\nsteane0.add_edge('X_COR', 'meas', check='True')\nsteane0.add_edge('meas', 'FAIL', check='logErr(meas[-1])')\n\n\nerr_model = qs.noise.E1\nq = [1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 0.5]\nerr_params = {'q': q}\n\nbegin = time.time()\nstim_sam = qs.SubsetSampler(protocol=steane0, simulator=qs.StimSimulator,  p_max={'q': 0.1}, err_model=err_model, err_params=err_params, L=3)\nstim_sam.run(2000)\nend = time.time()\nstim_time = end-begin\n\nv2 = stim_sam.stats()[0]\nw2 = stim_sam.stats()[2]\n\n\n\n\n\nInput = qsample\n\neft = qs.Circuit([  {\"init\": {0,1,2,4,3,5,6,7}},\n                    {\"H\": {0,1,3}},\n                    {\"CNOT\": {(0,4)}},\n                    {\"CNOT\": {(1,2)}},\n                    {\"CNOT\": {(3,5)}},\n                    {\"CNOT\": {(0,6)}},\n                    {\"CNOT\": {(3,4)}},\n                    {\"CNOT\": {(1,5)}},\n                    {\"CNOT\": {(0,2)}},\n                    {\"CNOT\": {(5,6)}},\n                    {\"CNOT\": {(4,7)}},\n                    {\"CNOT\": {(2,7)}},\n                    {\"CNOT\": {(5,7)}},\n                    {\"measure\": {7}} ])\n\nsz_123 = qs.Circuit([   {\"init\": {8}},\n                        {\"CNOT\": {(0,8)}},\n                        {\"CNOT\": {(1,8)}},\n                        {\"CNOT\": {(3,8)}},\n                        {\"CNOT\": {(6,8)}},\n                        {\"measure\": {8}}])\n\nmeas7 = qs.Circuit([ {\"measure\": {0,1,2,3,4,5,6}} ], noisy=False)\n\n\n\n\n\nk1 = 0b0001111\nk2 = 0b1010101\nk3 = 0b0110011\nk12 = k1 ^ k2\nk23 = k2 ^ k3\nk13 = k1 ^ k3\nk123 = k12 ^ k3\nstabilizerGenerators = [k1, k2, k3]\nstabilizerSet = [0, k1, k2, k3, k12, k23, k13, k123]\n\ndef hamming2(x, y):\n    count, z = 0, x ^ y\n    while z:\n        count += 1\n        z &= z - 1\n    return count\n\nfails = []\n\ndef logErr(out):\n    global fails\n    \n    c = np.array([hamming2(out, i) for i in stabilizerSet])\n    d = np.flatnonzero(c &lt;= 1)\n    e = np.array([hamming2(out ^ (0b1111111), i) for i in stabilizerSet])\n    f = np.flatnonzero(e &lt;= 1)\n    if len(d) != 0:\n        return False\n    elif len(f) != 0:\n        fails.append(out)\n        return True\n    if len(d) != 0 and len(f) != 0: \n        raise('-!-!-CANNOT BE TRUE-!-!-')\n\ndef flagged_z_look_up_table_1(z):\n    s = [z]\n\n    if s == [1]:\n        return True\n    else: \n        return False\n\nfunctions = {\"logErr\": logErr, \"lut\": flagged_z_look_up_table_1}\n\nsteane0 = qs.Protocol(check_functions=functions, fault_tolerant=True)\n\nsteane0.add_nodes_from(['ENC', 'Z2', 'meas'], circuits=[eft, sz_123, meas7])\nsteane0.add_node('X_COR', circuit=qs.Circuit([{'X': {6}}], noisy=True))\nsteane0.add_edge('START', 'ENC', check='True')\nsteane0.add_edge('ENC', 'meas', check='ENC[-1]==0')\nsteane0.add_edge('ENC', 'Z2', check='ENC[-1]==1')\nsteane0.add_edge('Z2', 'X_COR', check='lut(Z2[-1])')\nsteane0.add_edge('Z2', 'meas', check='not lut(Z2[-1])')\nsteane0.add_edge('X_COR', 'meas', check='True')\nsteane0.add_edge('meas', 'FAIL', check='logErr(meas[-1])')\n\n\nerr_model = qs.noise.E1\nq = [1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 0.5]\nerr_params = {'q': q}\n\nbegin = time.time()\nss_sam = qs.SubsetSampler(protocol=steane0, simulator=qs.StabilizerSimulator,  p_max={'q': 0.1}, err_model=err_model, err_params=err_params, L=3)\nss_sam.run(2000)\nend = time.time()\nqsample_time = end-begin\n\nv1 = ss_sam.stats()[0]\nw1 = ss_sam.stats()[2]\n\n\n\n\n\n\nInput = QASM\n\neft = qs.Circuit().from_qasm_circuit(\"\"\"OPENQASM 2.0;\ninclude \"qelib1.inc\";\n\nqreg q[8];\ncreg c[1];\n\nh q[0];\nh q[1];\nh q[3];\n\ncx q[0], q[4];\ncx q[1], q[2];\ncx q[3], q[5];\ncx q[0], q[6];\ncx q[3], q[4];\ncx q[1], q[5];\ncx q[0], q[2];\ncx q[5], q[6];\ncx q[4], q[7];\ncx q[2], q[7];\ncx q[5], q[7];\n\nmeasure q[7] -&gt; c[0];\"\"\")\n\nsz_123 = qs.Circuit().from_qasm_circuit(\"\"\"OPENQASM 2.0;\ninclude \"qelib1.inc\";\n\nqreg q[9];\ncreg c[1];\n\n// Initialize qubit 8 (default is |0‚ü©)\n\n// Apply CNOT gates with control qubits 0,1,3,6 and target qubit 8\ncx q[0], q[8];\ncx q[1], q[8];\ncx q[3], q[8];\ncx q[6], q[8];\n\n// Measure qubit 8 into classical bit 0\nmeasure q[8] -&gt; c[0];\"\"\")\n\nmeas7 = qs.Circuit(noisy=False).from_qasm_circuit(\"\"\"OPENQASM 2.0;\ninclude \"qelib1.inc\";\n\nqreg q[7];\ncreg c[7];\n\nmeasure q[0] -&gt; c[0];\nmeasure q[1] -&gt; c[1];\nmeasure q[2] -&gt; c[2];\nmeasure q[3] -&gt; c[3];\nmeasure q[4] -&gt; c[4];\nmeasure q[5] -&gt; c[5];\nmeasure q[6] -&gt; c[6];\"\"\")\n\n\n\n\n\nk1 = 0b0001111\nk2 = 0b1010101\nk3 = 0b0110011\nk12 = k1 ^ k2\nk23 = k2 ^ k3\nk13 = k1 ^ k3\nk123 = k12 ^ k3\nstabilizerGenerators = [k1, k2, k3]\nstabilizerSet = [0, k1, k2, k3, k12, k23, k13, k123]\n\ndef hamming2(x, y):\n    count, z = 0, x ^ y\n    while z:\n        count += 1\n        z &= z - 1\n    return count\n\nfails = []\n\ndef logErr(out):\n    global fails\n    \n    c = np.array([hamming2(out, i) for i in stabilizerSet])\n    d = np.flatnonzero(c &lt;= 1)\n    e = np.array([hamming2(out ^ (0b1111111), i) for i in stabilizerSet])\n    f = np.flatnonzero(e &lt;= 1)\n    if len(d) != 0:\n        return False\n    elif len(f) != 0:\n        fails.append(out)\n        return True\n    if len(d) != 0 and len(f) != 0: \n        raise('-!-!-CANNOT BE TRUE-!-!-')\n\ndef flagged_z_look_up_table_1(z):\n    s = [z]\n\n    if s == [1]:\n        return True\n    else: \n        return False\n\nfunctions = {\"logErr\": logErr, \"lut\": flagged_z_look_up_table_1}\n\nsteane0 = qs.Protocol(check_functions=functions, fault_tolerant=True)\n\nsteane0.add_nodes_from(['ENC', 'Z2', 'meas'], circuits=[eft, sz_123, meas7])\nsteane0.add_node('X_COR', circuit=qs.Circuit().from_qasm_circuit(\"\"\"OPENQASM 2.0;\ninclude \"qelib1.inc\";\n\nqreg q[8];\nx q[6];\"\"\"))\nsteane0.add_edge('START', 'ENC', check='True')\nsteane0.add_edge('ENC', 'meas', check='ENC[-1]==0')\nsteane0.add_edge('ENC', 'Z2', check='ENC[-1]==1')\nsteane0.add_edge('Z2', 'X_COR', check='lut(Z2[-1])')\nsteane0.add_edge('Z2', 'meas', check='not lut(Z2[-1])')\nsteane0.add_edge('X_COR', 'meas', check='True')\nsteane0.add_edge('meas', 'FAIL', check='logErr(meas[-1])')\n\n\nerr_model = qs.noise.E1\nq = [1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 0.5]\nerr_params = {'q': q}\n\nbegin = time.time()\nss_sam = qs.SubsetSampler(protocol=steane0, simulator=qs.StimSimulator,  p_max={'q': 0.1}, err_model=err_model, err_params=err_params, L=3)\nss_sam.run(2000)\nend = time.time()\nstim_time = end-begin\n\nv3 = ss_sam.stats()[0]\nw3 = ss_sam.stats()[2]\n\n\n\n\n\n\nInput = Qiskit\n\nq = qiskit.QuantumRegister(8)\nc = qiskit.ClassicalRegister(1)\neft = qiskit.QuantumCircuit(q, c)\n\neft.h(q[0])\neft.h(q[1])\neft.h(q[3])\n\n\neft.cx(q[0], q[4])\neft.cx(q[1], q[2])\neft.cx(q[3], q[5])\neft.cx(q[0], q[6])\neft.cx(q[3], q[4])\neft.cx(q[1], q[5])\neft.cx(q[0], q[2])\neft.cx(q[5], q[6])\neft.cx(q[4], q[7])\neft.cx(q[2], q[7])\neft.cx(q[5], q[7])\n\neft.measure(q[7], c[0])\n\neft = qs.Circuit().from_qiskit_circuit(eft)\n\n# ==========\n\nq = qiskit.QuantumRegister(7)\nc = qiskit.ClassicalRegister(7)\nmeas7 = qiskit.QuantumCircuit(q, c)\n\nmeas7.measure(q[0], c[0])\nmeas7.measure(q[1], c[1])\nmeas7.measure(q[2], c[2])\nmeas7.measure(q[3], c[3])\nmeas7.measure(q[4], c[4])\nmeas7.measure(q[5], c[5])\nmeas7.measure(q[6], c[6])\n\n\nmeas7 = qs.Circuit().from_qiskit_circuit(meas7)\n\n# =========\nq = qiskit.QuantumRegister(9)\nc = qiskit.ClassicalRegister(1)\nsz_123 = qiskit.QuantumCircuit(q, c)\n\nsz_123.cx(q[0], q[8])\nsz_123.cx(q[1], q[8])\nsz_123.cx(q[3], q[8])\nsz_123.cx(q[6], q[8])\nsz_123.measure(q[8], c[0])\n\n\nsz_123 = qs.Circuit().from_qiskit_circuit(sz_123)\n\n# ===========\n\n\n\n\n\n\nk1 = 0b0001111\nk2 = 0b1010101\nk3 = 0b0110011\nk12 = k1 ^ k2\nk23 = k2 ^ k3\nk13 = k1 ^ k3\nk123 = k12 ^ k3\nstabilizerGenerators = [k1, k2, k3]\nstabilizerSet = [0, k1, k2, k3, k12, k23, k13, k123]\n\ndef hamming2(x, y):\n    count, z = 0, x ^ y\n    while z:\n        count += 1\n        z &= z - 1\n    return count\n\nfails = []\n\ndef logErr(out):\n    global fails\n    \n    c = np.array([hamming2(out, i) for i in stabilizerSet])\n    d = np.flatnonzero(c &lt;= 1)\n    e = np.array([hamming2(out ^ (0b1111111), i) for i in stabilizerSet])\n    f = np.flatnonzero(e &lt;= 1)\n    if len(d) != 0:\n        return False\n    elif len(f) != 0:\n        fails.append(out)\n        return True\n    if len(d) != 0 and len(f) != 0: \n        raise('-!-!-CANNOT BE TRUE-!-!-')\n\ndef flagged_z_look_up_table_1(z):\n    s = [z]\n\n    if s == [1]:\n        return True\n    else: \n        return False\n\nfunctions = {\"logErr\": logErr, \"lut\": flagged_z_look_up_table_1}\n\nsteane0 = qs.Protocol(check_functions=functions, fault_tolerant=True)\n\nsteane0.add_nodes_from(['ENC', 'Z2', 'meas'], circuits=[eft, sz_123, meas7])\nsteane0.add_node('X_COR', circuit=qs.Circuit().from_qasm_circuit(\"\"\"OPENQASM 2.0;\ninclude \"qelib1.inc\";\n\nqreg q[8];\nx q[6];\"\"\"))\nsteane0.add_edge('START', 'ENC', check='True')\nsteane0.add_edge('ENC', 'meas', check='ENC[-1]==0')\nsteane0.add_edge('ENC', 'Z2', check='ENC[-1]==1')\nsteane0.add_edge('Z2', 'X_COR', check='lut(Z2[-1])')\nsteane0.add_edge('Z2', 'meas', check='not lut(Z2[-1])')\nsteane0.add_edge('X_COR', 'meas', check='True')\nsteane0.add_edge('meas', 'FAIL', check='logErr(meas[-1])')\n\n\nerr_model = qs.noise.E1\nq = [1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 0.5]\nerr_params = {'q': q}\n\nbegin = time.time()\nss_sam = qs.SubsetSampler(protocol=steane0, simulator=qs.StimSimulator,  p_max={'q': 0.1}, err_model=err_model, err_params=err_params, L=3)\nss_sam.run(2000)\nend = time.time()\nstim_time = end-begin\n\nv4 = ss_sam.stats()[0]\nw4 = ss_sam.stats()[2]\n\n\n\n\n\nplt.plot(q, v1, label = \"Input = QSample\")\nplt.plot(q, w1)\nplt.plot(q, v2, label = \"Input = STIM\")\nplt.plot(q, w2)\nplt.plot(q, v3, label = \"Input = QASM\")\nplt.plot(q, w3)\nplt.plot(q, v4, label = \"Input = Qiskit\")\nplt.plot(q, w4)\n\nplt.xscale('log')\nplt.yscale('log')\nplt.legend()\n\nprint(qsample_time)\nprint(stim_time)\n\n1.8705940246582031\n0.95461106300354\n\n\n\n\n\n\n\n\n\n\nqsample_times = []\nstim_times = []\n\nsamples = [100, 300, 1000, 3000, 10000, 50000]\n\nfor s in samples:\n    begin = time.time()\n    stim_sam = qs.SubsetSampler(protocol=steane0, simulator=qs.StabilizerSimulator,  p_max={'q': 0.1}, err_model=err_model, err_params=err_params, L=3)\n    stim_sam.run(s)\n    end = time.time()\n    qsample_times.append(end-begin)\n\n    begin = time.time()\n    ss_sam = qs.SubsetSampler(protocol=steane0, simulator=qs.StimSimulator,  p_max={'q': 0.01}, err_model=err_model, err_params=err_params, L=3)\n    ss_sam.run(s)\n    end = time.time()\n    stim_times.append(end-begin)\n\nplt.plot(samples, stim_sam.stats()[0])\nplt.plot(samples, stim_sam.stats()[2])\nplt.plot(samples, ss_sam.stats()[0])\nplt.plot(samples, ss_sam.stats()[2])\nplt.xscale('log')\nplt.yscale('log')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\nInput In [11], in &lt;cell line: 6&gt;()\n     13 begin = time.time()\n     14 ss_sam = qs.SubsetSampler(protocol=steane0, simulator=qs.StimSimulator,  p_max={'q': 0.01}, err_model=err_model, err_params=err_params, L=3)\n---&gt; 15 ss_sam.run(s)\n     16 end = time.time()\n     17 stim_times.append(end-begin)\n\nFile ~/Desktop/qsample/qsample/sampler/subset.py:138, in SubsetSampler.run(self, n_shots, callbacks)\n    135 self.stop_sampling = False # Flag can be controlled in callbacks\n    136 callbacks.on_sampler_begin()\n--&gt; 138 for _ in tqdm(range(n_shots), desc=f\"p={tuple(map('{:.2e}'.format, self.p_max))}\"):\n    139     tableau = None\n    140     callbacks.on_protocol_begin()\n\nFile /opt/anaconda3/lib/python3.9/site-packages/tqdm/notebook.py:258, in tqdm_notebook.__iter__(self)\n    256 try:\n    257     it = super(tqdm_notebook, self).__iter__()\n--&gt; 258     for obj in it:\n    259         # return super(tqdm...) will not catch exception\n    260         yield obj\n    261 # NB: except ... [ as ...] breaks IPython async KeyboardInterrupt\n\nFile /opt/anaconda3/lib/python3.9/site-packages/tqdm/std.py:1210, in tqdm.__iter__(self)\n   1208 finally:\n   1209     self.n = n\n-&gt; 1210     self.close()\n\nFile /opt/anaconda3/lib/python3.9/site-packages/tqdm/notebook.py:290, in tqdm_notebook.close(self)\n    288 else:\n    289     if self.leave:\n--&gt; 290         self.disp(bar_style='success', check_delay=False)\n    291     else:\n    292         self.disp(close=True, check_delay=False)\n\nFile /opt/anaconda3/lib/python3.9/site-packages/tqdm/notebook.py:177, in tqdm_notebook.display(self, msg, pos, close, bar_style, check_delay)\n    174     left, right = '', escape(msg)\n    176 # Update description\n--&gt; 177 ltext.value = left\n    178 # never clear the bar (signal: msg='')\n    179 if right:\n\nFile /opt/anaconda3/lib/python3.9/site-packages/traitlets/traitlets.py:606, in TraitType.__set__(self, obj, value)\n    604     raise TraitError('The \"%s\" trait is read-only.' % self.name)\n    605 else:\n--&gt; 606     self.set(obj, value)\n\nFile /opt/anaconda3/lib/python3.9/site-packages/traitlets/traitlets.py:595, in TraitType.set(self, obj, value)\n    591     silent = False\n    592 if silent is not True:\n    593     # we explicitly compare silent to True just in case the equality\n    594     # comparison above returns something other than True/False\n--&gt; 595     obj._notify_trait(self.name, old_value, new_value)\n\nFile /opt/anaconda3/lib/python3.9/site-packages/traitlets/traitlets.py:1219, in HasTraits._notify_trait(self, name, old_value, new_value)\n   1218 def _notify_trait(self, name, old_value, new_value):\n-&gt; 1219     self.notify_change(Bunch(\n   1220         name=name,\n   1221         old=old_value,\n   1222         new=new_value,\n   1223         owner=self,\n   1224         type='change',\n   1225     ))\n\nFile /opt/anaconda3/lib/python3.9/site-packages/ipywidgets/widgets/widget.py:605, in Widget.notify_change(self, change)\n    601 if self.comm is not None and self.comm.kernel is not None:\n    602     # Make sure this isn't information that the front-end just sent us.\n    603     if name in self.keys and self._should_send_property(name, getattr(self, name)):\n    604         # Send new state to front-end\n--&gt; 605         self.send_state(key=name)\n    606 super(Widget, self).notify_change(change)\n\nFile /opt/anaconda3/lib/python3.9/site-packages/ipywidgets/widgets/widget.py:489, in Widget.send_state(self, key)\n    487 state, buffer_paths, buffers = _remove_buffers(state)\n    488 msg = {'method': 'update', 'state': state, 'buffer_paths': buffer_paths}\n--&gt; 489 self._send(msg, buffers=buffers)\n\nFile /opt/anaconda3/lib/python3.9/site-packages/ipywidgets/widgets/widget.py:737, in Widget._send(self, msg, buffers)\n    735 \"\"\"Sends a message to the model in the front-end.\"\"\"\n    736 if self.comm is not None and self.comm.kernel is not None:\n--&gt; 737     self.comm.send(data=msg, buffers=buffers)\n\nFile /opt/anaconda3/lib/python3.9/site-packages/ipykernel/comm/comm.py:122, in Comm.send(self, data, metadata, buffers)\n    120 def send(self, data=None, metadata=None, buffers=None):\n    121     \"\"\"Send a message to the frontend-side version of this comm\"\"\"\n--&gt; 122     self._publish_msg('comm_msg',\n    123         data=data, metadata=metadata, buffers=buffers,\n    124     )\n\nFile /opt/anaconda3/lib/python3.9/site-packages/ipykernel/comm/comm.py:66, in Comm._publish_msg(self, msg_type, data, metadata, buffers, **keys)\n     64 metadata = {} if metadata is None else metadata\n     65 content = json_clean(dict(data=data, comm_id=self.comm_id, **keys))\n---&gt; 66 self.kernel.session.send(self.kernel.iopub_socket, msg_type,\n     67     content,\n     68     metadata=json_clean(metadata),\n     69     parent=self.kernel.get_parent(\"shell\"),\n     70     ident=self.topic,\n     71     buffers=buffers,\n     72 )\n\nFile /opt/anaconda3/lib/python3.9/site-packages/jupyter_client/session.py:717, in Session.send(self, stream, msg_or_type, content, parent, ident, buffers, track, header, metadata)\n    715     buffers = buffers or msg.get('buffers', [])\n    716 else:\n--&gt; 717     msg = self.msg(msg_or_type, content=content, parent=parent,\n    718                    header=header, metadata=metadata)\n    719 if self.check_pid and not os.getpid() == self.pid:\n    720     get_logger().warning(\"WARNING: attempted to send message from fork\\n%s\",\n    721         msg\n    722     )\n\nFile /opt/anaconda3/lib/python3.9/site-packages/jupyter_client/session.py:577, in Session.msg(self, msg_type, content, parent, header, metadata)\n    570 \"\"\"Return the nested message dict.\n    571 \n    572 This format is different from what is sent over the wire. The\n    573 serialize/deserialize methods converts this nested message dict to the wire\n    574 format, which is a list of message parts.\n    575 \"\"\"\n    576 msg = {}\n--&gt; 577 header = self.msg_header(msg_type) if header is None else header\n    578 msg['header'] = header\n    579 msg['msg_id'] = header['msg_id']\n\nFile /opt/anaconda3/lib/python3.9/site-packages/jupyter_client/session.py:567, in Session.msg_header(self, msg_type)\n    566 def msg_header(self, msg_type):\n--&gt; 567     return msg_header(self.msg_id, msg_type, self.username, self.session)\n\nFile /opt/anaconda3/lib/python3.9/site-packages/jupyter_client/session.py:220, in msg_header(msg_id, msg_type, username, session)\n    218 def msg_header(msg_id, msg_type, username, session):\n    219     \"\"\"Create a new message header\"\"\"\n--&gt; 220     date = utcnow()\n    221     version = protocol_version\n    222     return locals()\n\nFile /opt/anaconda3/lib/python3.9/site-packages/jupyter_client/session.py:151, in utcnow()\n    149 def utcnow():\n    150     \"\"\"Return timezone-aware UTC timestamp\"\"\"\n--&gt; 151     return datetime.utcnow().replace(tzinfo=utc)\n\nKeyboardInterrupt: \n\n\n\n\nplt.plot(samples, qsample_times, label = 'stabilizer sim.')\nplt.plot(samples, stim_times, label = 'stim sim.')\nplt.legend()\nplt.xscale('log')\nplt.yscale('log')\nplt.ylabel('time (s)')\nplt.xlabel('# of samples')\n\nprint('Average ratio of stim time/stabilizer time: {:.2f}'.format(np.average(np.array(stim_times)/np.array(qsample_times))))\n\nAverage ratio of stim time/stabilizer time: 0.45",
    "crumbs": [
      "Examples",
      "Input = STIM"
    ]
  },
  {
    "objectID": "examples/Surface_code.html",
    "href": "examples/Surface_code.html",
    "title": "",
    "section": "",
    "text": "import qsample as qs\nimport qiskit\nimport time\nimport stim\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nimport re\nfrom tqdm.notebook import tqdm\nimport pymatching\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSurface code\n\ncircuit = stim.Circuit.generated(\"surface_code:rotated_memory_x\", rounds=1, distance=3)\ncircuit.diagram(\"timeline-svg\")\n\n\n\n\n\n\n\n\n\n\"\"\"\nIMPORTANT NOTE: The predictions output by pyMatching depend on the error rate of the STIM circuit,\nbut the prediction error is nearly independent of the error rate if it is sufficient low (which is the\nregime we care about in QSample anyway), so in order to generate the first detector error model and \nMatching object, it is advisable to use a physical error rate by the lower end of your range.\n\n\"\"\"\n\ncircuit = stim.Circuit.generated(\"surface_code:rotated_memory_x\", rounds=1, distance=3, after_clifford_depolarization=0.05,\n    after_reset_flip_probability=0.001,\n    before_measure_flip_probability=0.001,\n    before_round_data_depolarization=0.001,)\nsurface_code = qs.Circuit(noisy=True).from_stim_circuit(circuit)\n\nmatching = pymatching.Matching(surface_code.dem)\nnum_detectors = matching.num_detectors\ndetector_array = surface_code.detector_array\n\n\ncorr = qs.Circuit(noisy=False).from_stim_circuit(\"\"\"X 1 8 15\"\"\")\nmeas = qs.Circuit(noisy=False).from_stim_circuit(\"\"\"M 1 8 15\"\"\")\n\nround_ = 0\ndef reset_count():\n    global round_\n    round_=0\n    return True\n\ndef increase_count():\n    global round_\n    round_+=1\n    return round_\n\ndef count():\n    global round_\n    return round_\n\ndef int2meas(out):\n    result = []\n    for i in np.arange(surface_code.n_measurements)[::-1]:\n        result.append(out//(2**i))\n        out-=result[-1]*2**i\n    return result\n\ndef measurement2detector(out, detector_array):\n    out = int2meas(out[-1])\n    detection_events = np.zeros(num_detectors)\n    for ii in range(num_detectors):\n        event = 0\n        for jj in detector_array[ii]:\n            event^=int(out[jj])\n        detection_events[ii]=event\n    return detection_events\n    \ndef decoder(out):\n    detection_events = measurement2detector(out, detector_array)\n    result = matching.decode(detection_events)\n    return result\n\ndef logErr(out):\n    return out[0] in [1, 2, 4, 7]\n\nfunctions = {'decoder': decoder, 'matching':matching, 'logErr':logErr,\n            'reset_count': reset_count, 'count': count, 'increase_count': increase_count}\nsurface = qs.Protocol(check_functions=functions)\n\n\nn_rounds = 4\nsurface.add_nodes_from(['SC', 'corr', 'meas'], circuits=[surface_code, corr, meas])\nsurface.add_node('Round_counter', circuit=qs.Circuit([{\"I\": {0}}],noisy=False))\nsurface.add_edge('START', 'Round_counter', check='reset_count()')\nsurface.add_edge('Round_counter', 'SC', check='increase_count()')\nsurface.add_edge('SC', 'corr', check='decoder(SC)')\nsurface.add_edge('SC', 'Round_counter', check=f'(not decoder(SC)) and count()&lt;{n_rounds}')\nsurface.add_edge('SC', 'meas', check=f'(not decoder(SC)) and count()=={n_rounds}')\nsurface.add_edge('corr', 'Round_counter', check=f'count()&lt;{n_rounds}')\nsurface.add_edge('corr', 'meas', check=f'count()=={n_rounds}')\nsurface.add_edge('meas', 'FAIL', check='logErr(meas)')\n\n\nerr_model = qs.noise.E1\nq = [1e-5, 1e-4, 1e-3, 1e-2, 1e-1]\nerr_params = {'q': q}\n\nbegin = time.time()\nss_sam = qs.SubsetSampler(protocol=surface, simulator=qs.StimSimulator,  p_max={'q': 0.01}, err_model=err_model, err_params=err_params, L=5)\nss_sam.run(25000)\nend = time.time()\nqsample_time = end-begin\n\nv1 = ss_sam.stats()[0]\nw1 = ss_sam.stats()[2]\n\nplt.plot(q, v1)\nplt.plot(q, w1)\nplt.xscale('log')\nplt.yscale('log')\nprint('time:', qsample_time, 's')\n\n\n\n\ntime: 53.046889781951904 s\n\n\n/Users/jhfontes/Desktop/qsample/qsample/sampler/subset.py:92: RuntimeWarning: invalid value encountered in sqrt\n  return np.broadcast_arrays(p_L, np.sqrt(var), p_L+delta, np.sqrt(var_up))\n\n\n\n\n\n\n\n\n\n\n\"\"\"\nIMPORTANT NOTE: The predictions output by pyMatching depend on the error rate of the STIM circuit,\nbut the prediction error is nearly independent of the error rate if it is sufficient low (which is the\nregime we care about in QSample anyway), so in order to generate the first detector error model and \nMatching object, it is advisable to use a physical error rate by the lower end of your range.\n\"\"\"\n\ncircuit = stim.Circuit.generated(\"surface_code:rotated_memory_x\", rounds=1, distance=3, after_clifford_depolarization=0.05,\n    after_reset_flip_probability=0.001,\n    before_measure_flip_probability=0.001,\n    before_round_data_depolarization=0.001,)\nsurface_code = qs.Circuit(noisy=True).from_stim_circuit(circuit)\n\nmatching = pymatching.Matching(surface_code.dem)\nnum_detectors = matching.num_detectors\ndetector_array = surface_code.detector_array\n\n\ncorr = qs.Circuit(noisy=False).from_stim_circuit(\"\"\"X 1 8 15\"\"\")\nmeas = qs.Circuit(noisy=False).from_stim_circuit(\"\"\"M 1 8 15\"\"\")\n\nround_ = 0\ndef reset_count():\n    global round_\n    round_=0\n    return True\n\ndef increase_count():\n    global round_\n    round_+=1\n    return round_\n\ndef count():\n    global round_\n    return round_\n\ndef int2meas(out):\n    result = []\n    for i in np.arange(surface_code.n_measurements)[::-1]:\n        result.append(out//(2**i))\n        out-=result[-1]*2**i\n    return result\n\ndef measurement2detector(out, detector_array):\n    out = int2meas(out[-1])\n    detection_events = np.zeros(num_detectors)\n    for ii in range(num_detectors):\n        event = 0\n        for jj in detector_array[ii]:\n            event^=int(out[jj])\n        detection_events[ii]=event\n    return detection_events\n    \ndef decoder(out):\n    detection_events = measurement2detector(out, detector_array)\n    result = matching.decode(detection_events)\n    return result\n\ndef logErr(out):\n    return out[0] in [1, 2, 4, 7]\n\nfunctions = {'decoder': decoder, 'matching':matching, 'logErr':logErr,\n            'reset_count': reset_count, 'count': count, 'increase_count': increase_count}\nsurface = qs.Protocol(check_functions=functions)\n\n\nn_rounds = 1\nsurface.add_nodes_from(['SC', 'corr', 'meas'], circuits=[surface_code, corr, meas])\nsurface.add_node('Round_counter', circuit=qs.Circuit([{\"I\": {0}}],noisy=False))\nsurface.add_edge('START', 'Round_counter', check='reset_count()')\nsurface.add_edge('Round_counter', 'SC', check='increase_count()')\nsurface.add_edge('SC', 'corr', check='decoder(SC)')\nsurface.add_edge('SC', 'Round_counter', check=f'(not decoder(SC)) and count()&lt;{n_rounds}')\nsurface.add_edge('SC', 'meas', check=f'(not decoder(SC)) and count()=={n_rounds}')\nsurface.add_edge('corr', 'Round_counter', check=f'count()&lt;{n_rounds}')\nsurface.add_edge('corr', 'meas', check=f'count()=={n_rounds}')\nsurface.add_edge('meas', 'FAIL', check='logErr(meas)')\n\n\nerr_model = qs.noise.E1\nq = [1e-5, 1e-4, 1e-3, 1e-2, 1e-1]\nerr_params = {'q': q}\n\nbegin = time.time()\nss_sam = qs.SubsetSampler(protocol=surface, simulator=qs.StimSimulator,  p_max={'q': 0.01}, err_model=err_model, err_params=err_params, L=5)\nss_sam.run(25000)\nend = time.time()\nqsample_time = end-begin\n\nv1b = ss_sam.stats()[0]\nw1b = ss_sam.stats()[2]\n\nplt.plot(q, v1)\nplt.plot(q, w1)\nplt.plot(q, v1b)\nplt.plot(q, w1b)\nplt.xscale('log')\nplt.yscale('log')\nprint('time:', qsample_time, 's')\n\n\n\n\n/Users/jhfontes/Desktop/qsample/qsample/sampler/subset.py:92: RuntimeWarning: invalid value encountered in sqrt\n  return np.broadcast_arrays(p_L, np.sqrt(var), p_L+delta, np.sqrt(var_up))\n\n\ntime: 14.701840162277222 s\n\n\n\n\n\n\n\n\n\n\n\"\"\"\nIMPORTANT NOTE: The predictions output by pyMatching depend on the error rate of the STIM circuit,\nbut the prediction error is nearly independent of the error rate if it is sufficient low (which is the\nregime we care about in QSample anyway), so in order to generate the first detector error model and \nMatching object, it is advisable to use a physical error rate by the lower end of your range.\n\"\"\"\n\ncircuit = stim.Circuit.generated(\"surface_code:rotated_memory_x\", rounds=1, distance=3, after_clifford_depolarization=0.05,\n    after_reset_flip_probability=0.001,\n    before_measure_flip_probability=0.001,\n    before_round_data_depolarization=0.001,)\nsurface_code = qs.Circuit(noisy=True).from_stim_circuit(circuit)\n\nmatching = pymatching.Matching(surface_code.dem)\nnum_detectors = matching.num_detectors\ndetector_array = surface_code.detector_array\n\n\ncorr = qs.Circuit(noisy=False).from_stim_circuit(\"\"\"X 1 8 15\"\"\")\nmeas = qs.Circuit(noisy=False).from_stim_circuit(\"\"\"M 1 8 15\"\"\")\n\nround_ = 0\ndef reset_count():\n    global round_\n    round_=0\n    return True\n\ndef increase_count():\n    global round_\n    round_+=1\n    return round_\n\ndef count():\n    global round_\n    return round_\n\ndef int2meas(out):\n    result = []\n    for i in np.arange(surface_code.n_measurements)[::-1]:\n        result.append(out//(2**i))\n        out-=result[-1]*2**i\n    return result\n\ndef measurement2detector(out, detector_array):\n    out = int2meas(out[-1])\n    detection_events = np.zeros(num_detectors)\n    for ii in range(num_detectors):\n        event = 0\n        for jj in detector_array[ii]:\n            event^=int(out[jj])\n        detection_events[ii]=event\n    return detection_events\n    \ndef decoder(out):\n    detection_events = measurement2detector(out, detector_array)\n    result = matching.decode(detection_events)\n    return result\n\ndef logErr(out):\n    return out[0] in [1, 2, 4, 7]\n\nfunctions = {'decoder': decoder, 'matching':matching, 'logErr':logErr,\n            'reset_count': reset_count, 'count': count, 'increase_count': increase_count}\nsurface = qs.Protocol(check_functions=functions)\n\n\nn_rounds = 8\nsurface.add_nodes_from(['SC', 'corr', 'meas'], circuits=[surface_code, corr, meas])\nsurface.add_node('Round_counter', circuit=qs.Circuit([{\"I\": {0}}],noisy=False))\nsurface.add_edge('START', 'Round_counter', check='reset_count()')\nsurface.add_edge('Round_counter', 'SC', check='increase_count()')\nsurface.add_edge('SC', 'corr', check='decoder(SC)')\nsurface.add_edge('SC', 'Round_counter', check=f'(not decoder(SC)) and count()&lt;{n_rounds}')\nsurface.add_edge('SC', 'meas', check=f'(not decoder(SC)) and count()=={n_rounds}')\nsurface.add_edge('corr', 'Round_counter', check=f'count()&lt;{n_rounds}')\nsurface.add_edge('corr', 'meas', check=f'count()=={n_rounds}')\nsurface.add_edge('meas', 'FAIL', check='logErr(meas)')\n\n\n\"\"\"RUNTIME &gt; 20 min\n\nerr_model = qs.noise.E1\nq = [1e-5, 1e-4, 1e-3, 1e-2, 1e-1]\nerr_params = {'q': q}\n\nbegin = time.time()\nss_sam = qs.SubsetSampler(protocol=surface, simulator=qs.StimSimulator,  p_max={'q': 0.01}, err_model=err_model, err_params=err_params, L=5)\nss_sam.run(25000)\nend = time.time()\nqsample_time = end-begin\n\nv1 = ss_sam.stats()[0]\nw1 = ss_sam.stats()[2]\n\nplt.plot(q, v1)\nplt.plot(q, w1)\nplt.xscale('log')\nplt.yscale('log')\nprint('time:', qsample_time, 's')\n\"\"\"\n\n\n\n\n\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\nCell In[12], line 13\n     10 end = time.time()\n     11 qsample_time = end-begin\n---&gt; 13 v1 = ss_sam.stats()[0]\n     14 w1 = ss_sam.stats()[2]\n     16 plt.plot(q, v1)\n\nFile ~/Desktop/qsample/qsample/sampler/subset.py:89, in SubsetSampler.stats(self, err_params)\n     87 delta = self.tree.delta\n     88 var = self.tree.var(mode=1)\n---&gt; 89 var_up = self.tree.var(mode=0)\n     91 self.tree.constants = _constants\n     92 return np.broadcast_arrays(p_L, np.sqrt(var), p_L+delta, np.sqrt(var_up))\n\nFile ~/Desktop/qsample/qsample/sampler/tree.py:532, in Tree.var(self, mode)\n    530 for leaf in leaves: # path variances\n    531     if self.path_weight(leaf) &gt;= 1: # exclude weight-0 paths\n--&gt; 532         acc += self.path_var(leaf)\n    535 # Add contributions to variance from no-fail paths\n    536 nf_leaves = set(n for n in leaf_set.difference(self.marked) if isinstance(n,Variable) and not n.invariant and len(n.siblings)==0)\n\nFile ~/Desktop/qsample/qsample/sampler/tree.py:460, in Tree.path_var(self, node, zero_leaf)\n    458     v = self.value(n)**2\n    459     if zero_leaf and n == node: v = 0\n--&gt; 460     E2 *= v\n    461     VpE2 *= (n.var + v) if isinstance(n,Variable) else v\n    463 return VpE2 - E2\n\nKeyboardInterrupt:",
    "crumbs": [
      "Examples",
      "Surface code"
    ]
  },
  {
    "objectID": "examples/Teleportation.html",
    "href": "examples/Teleportation.html",
    "title": "QSample",
    "section": "",
    "text": "import qsample as qs\nimport time\nimport stim\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nimport re\nteleport = qs.Circuit([{\"init\": {0, 1, 2}},\n                       {\"H\": {1}},\n                       {\"CNOT\": {(1, 2)}},\n                       {\"CNOT\": {(0, 1)}},\n                       {\"H\": {0}},\n                       {\"measure\": {0, 1}}])\nmeas = qs.Circuit([{\"measure\": {2}}], noisy=False)\ndef lut(syn):\n    op = {0: 'I', 1: 'X', 2: 'Z', 3: 'Y'}[syn]\n    return qs.Circuit([{op: {2}}], noisy=False)\ntele_proto = qs.Protocol(check_functions={'lut': lut})\ntele_proto.add_nodes_from(['tele', 'meas'], circuits=[teleport, meas])\ntele_proto.add_edge('START', 'tele', check='True')\ntele_proto.add_edge('tele', 'COR', check='lut(tele[-1])')\ntele_proto.add_edge('COR', 'meas', check='True')\ntele_proto.add_edge('meas', 'FAIL', check='meas[-1] == 1')\n\ntele_proto.draw(figsize=(8,5))\nerr_model = qs.noise.E1\nq = [1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 0.5]\nerr_params = {'q': q}\nbegin = time.time()\nss_sam = qs.SubsetSampler(protocol=tele_proto, simulator=qs.StabilizerSimulator,  p_max={'q': 0.1}, err_model=err_model, err_params=err_params, L=3)\nss_sam.run(1000)\nend = time.time()\nqsample_time = end-begin\nv1 = ss_sam.stats()[0]",
    "crumbs": [
      "Examples",
      "QSample"
    ]
  },
  {
    "objectID": "examples/Teleportation.html#section-7",
    "href": "examples/Teleportation.html#section-7",
    "title": "QSample",
    "section": "",
    "text": "teleport_s = qs.Circuit(\"\"\"H 1\\nCNOT 1 2\\nCNOT 0 1\\nH 0\\nM 0 1\\n\"\"\")\n\nmeas = qs.Circuit(\"\"\"M 2\"\"\", noisy=False)\n\n\ndef lut(syn):\n    op = {0: 'I', 1: 'X', 2: 'Z', 3: 'Y'}[syn]\n    return qs.Circuit(\"\\n{} 2\\n\".format(op), noisy=False)\n\n\nbegin = time.time()\nss_sam = qs.SubsetSampler(protocol=tele_proto, simulator=qs.StimSimulator, p_max={'q': 0.1}, err_model=err_model, err_params=err_params, L=3)\nss_sam.run(1000)\nend = time.time()\nstim_time = end-begin\n\n\n\n\n\nv2 = ss_sam.stats()[0]\n\n\nplt.plot(q, v1)\nplt.plot(q, v2)\nplt.xscale('log')\nplt.yscale('log')\n\nprint(qsample_time)\nprint(stim_time)\n\n0.44299817085266113\n1.1689352989196777\n\n\n\n\n\n\n\n\n\n\nqsample_times = []\nstim_times = []\n\nsamples = [100, 300, 1000, 3000, 10000, 50000]\n\nfor s in samples:\n    begin = time.time()\n    ss_sam = qs.SubsetSampler(protocol=tele_proto, simulator=qs.StabilizerSimulator,  p_max={'q': 0.01}, err_model=err_model, err_params=err_params, L=3)\n    ss_sam.run(s)\n    end = time.time()\n    qsample_times.append(end-begin)\n\n    begin = time.time()\n    ss_sam = qs.SubsetSampler(protocol=tele_proto, simulator=qs.StimSimulator,  p_max={'q': 0.01}, err_model=err_model, err_params=err_params, L=3)\n    ss_sam.run(s)\n    end = time.time()\n    stim_times.append(end-begin)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplt.plot(samples, qsample_times, label = 'stabilizer sim.')\nplt.plot(samples, stim_times, label = 'stim sim.')\nplt.legend()\nplt.xscale('log')\nplt.yscale('log')\nplt.ylabel('time (s)')\nplt.xlabel('# of samples')\n\nprint('Average ratio of stim time/stabilizer time: {:.2f}'.format(np.average(np.array(stim_times)/np.array(qsample_times))))\n\nAverage ratio of stim time/stabilizer time: 0.84",
    "crumbs": [
      "Examples",
      "QSample"
    ]
  },
  {
    "objectID": "examples/GHZ.html",
    "href": "examples/GHZ.html",
    "title": "Qsample",
    "section": "",
    "text": "import qsample as qs\nimport time\nimport stim\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nimport re\n\n\nghz = qs.Circuit([ {\"init\": {0,1,2,3,4}},\n                   {\"H\": {0}},\n                   {\"CNOT\": {(0,1)}},\n                   {\"CNOT\": {(1,2)}},\n                   {\"CNOT\": {(2,3)}},\n                   {\"CNOT\": {(3,4)}},\n                   {\"CNOT\": {(0,4)}},\n                   {\"measure\": {4}}   ])\n\n# Define protocol for 1 round of repetition\n\ndef logErr(msmt_list):\n    return msmt_list[-1] == 1 # If True transition to FAIL\n\nfunctions = {'logErr': logErr}\n\nghz1 = qs.Protocol(check_functions=functions, fault_tolerant=False)\n\nghz1.add_node('ghz', circuit=ghz) # Add node with corresponding circuit\nghz1.add_edge('START', 'ghz', check='True') # Transition START -&gt; first circuit node always True\nghz1.add_edge('ghz', 'FAIL', check='logErr(ghz)')\n\n\nghz1.draw(figsize=(8,5))\n\n\n\n\n\n\n\n\n\nerr_model = qs.noise.E1\nq = [1e-5, 1e-3, 1e-1, 0.5]\nerr_params = {'q': q}\n\n\nbegin = time.time()\nss_sam = qs.SubsetSampler(protocol=ghz1, simulator=qs.StabilizerSimulator,  p_max={'q': 0.1}, err_model=err_model, err_params=err_params, L=3)\nss_sam.run(1000)\nend = time.time()\nqsample_time = end-begin\n\n\n\n\n\nqsample_times = []\nstim_times = []\n\nsamples = [100, 300, 1000, 3000, 10000, 50000]\n\nfor s in samples:\n    begin = time.time()\n    ss_sam = qs.SubsetSampler(protocol=ghz1, simulator=qs.StabilizerSimulator,  p_max={'q': 0.01}, err_model=err_model, err_params=err_params, L=3)\n    ss_sam.run(s)\n    end = time.time()\n    qsample_times.append(end-begin)\n\n    begin = time.time()\n    ss_sam = qs.SubsetSampler(protocol=ghz1, simulator=qs.StimSimulator,  p_max={'q': 0.01}, err_model=err_model, err_params=err_params, L=3)\n    ss_sam.run(s)\n    end = time.time()\n    stim_times.append(end-begin)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplt.plot(samples, qsample_times, label = 'stabilizer sim.')\nplt.plot(samples, stim_times, label = 'stim sim.')\nplt.legend()\nplt.xscale('log')\nplt.yscale('log')\nplt.ylabel('time (s)')\nplt.xlabel('# of samples')\n\nprint('Average ratio of stim time/stabilizer time: {:.2f}'.format(np.average(np.array(stim_times)/np.array(qsample_times))))\n\nAverage ratio of stim time/stabilizer time: 0.83",
    "crumbs": [
      "Examples",
      "GHZ.html"
    ]
  }
]