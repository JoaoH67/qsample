---

title: Samplers


keywords: fastai
sidebar: home_sidebar

summary: "Collection of different samplers for sampling logical failure rates from quantum error correction circuits"
description: "Collection of different samplers for sampling logical failure rates from quantum error correction circuits"
nb_path: "06_samplers.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 06_samplers.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Sampler" class="doc_header"><code>class</code> <code>Sampler</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/samplers.py#L25" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Sampler</code>(<strong><code>circuit</code></strong>, <strong><code>err_params</code></strong>)</p>
</blockquote>
<p>Sampler base class</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DirectSampler" class="doc_header"><code>class</code> <code>DirectSampler</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/samplers.py#L44" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DirectSampler</code>(<strong><code>circuit</code></strong>, <strong><code>err_params</code></strong>) :: <a href="/qsam/samplers.html#Sampler"><code>Sampler</code></a></p>
</blockquote>
<p>Direct Monte Carlo sampler</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SubsetSampler" class="doc_header"><code>class</code> <code>SubsetSampler</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/samplers.py#L134" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SubsetSampler</code>(<strong><code>circuit</code></strong>, <strong><code>err_params</code></strong>, <strong><code>subset_select_fn</code></strong>=<em><code>uniform_select</code></em>) :: <a href="/qsam/samplers.html#Sampler"><code>Sampler</code></a></p>
</blockquote>
<p>Monte Carlo subset sampler</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's see how the samplers work. First we create some circuit to sample from. Let's choose a simple GHZ preparation flag circuit. This circuit produces the four-qubit GHZ state $|GHZ\rangle=\frac{1}{\sqrt{2}}(|0000\rangle+|1111\rangle)$ on qubits 0-3. The fifth qubit (qubit no. 4) is the flag which we measure to be either +1 if our prepared GHZ-state is error-free or if there is only a weight-1 error on the state (Note, we use <strong>error</strong> instead of <strong>fault</strong> to highlight that that we are talking about the <strong>final faulty state</strong>). If the flag measurement yield -1 (i.e. 0 in binary logic) we know that an error of weight larger than 1 occured on our final state, i.e. $|GHZ\rangle\rightarrow E_w|GHZ\rangle$, where $w\gt 1$ is the error-weight. Only these events we want to count as logical errors. Thus, let us first define the circuit and the physical error probabilities at which we want to sample logical error rates:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">qsam.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">ghz</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">([</span> <span class="p">{</span><span class="s2">&quot;H&quot;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">}},</span>
                <span class="p">{</span><span class="s2">&quot;CNOT&quot;</span><span class="p">:</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)}},</span>
                <span class="p">{</span><span class="s2">&quot;CNOT&quot;</span><span class="p">:</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)}},</span>
                <span class="p">{</span><span class="s2">&quot;CNOT&quot;</span><span class="p">:</span> <span class="p">{(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)}},</span>
                <span class="p">{</span><span class="s2">&quot;CNOT&quot;</span><span class="p">:</span> <span class="p">{(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)}},</span>
                <span class="p">{</span><span class="s2">&quot;CNOT&quot;</span><span class="p">:</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)}},</span>
                <span class="p">{</span><span class="s2">&quot;measure&quot;</span><span class="p">:</span> <span class="p">{</span><span class="mi">4</span><span class="p">}}</span>   <span class="p">])</span>

<span class="n">ghz</span><span class="o">.</span><span class="n">failures</span><span class="p">[((</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">),)]</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span> <span class="c1"># define which measurement is a failure for this circuit</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">err_params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="n">p</span><span class="p">}</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next, we create a sampler object and run it for a specified number of samples. Let's start with the <a href="/qsam/samplers.html#DirectSampler"><code>DirectSampler</code></a>:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sam</span> <span class="o">=</span> <span class="n">DirectSampler</span><span class="p">(</span><span class="n">ghz</span><span class="p">,</span> <span class="n">err_params</span><span class="p">)</span>
<span class="n">p_L</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="n">sam</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Similarly, we can do the same sampling using the <a href="/qsam/samplers.html#SubsetSampler"><code>SubsetSampler</code></a>. For this, we need to provide the <code>p_max</code> and <code>delta_max</code> parameters additionally by which the maximum fault-weight subsets are determined we wish to include in the our sampling. We also note that the <code>run</code> method in this case gives us an upper and a lower bound on the logical error rate instead of a single <code>p_L</code> as before. <code>delta_max</code> is the distance between these bounds at the <code>p_max</code> value. So, for large <code>p_max</code>, larger fault-weight subsets become relevant and in turn <code>delta_max</code> would increase if we didn't include those.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sam</span> <span class="o">=</span> <span class="n">SubsetSampler</span><span class="p">(</span><span class="n">ghz</span><span class="p">,</span> <span class="n">err_params</span><span class="p">)</span>
<span class="n">p_L_low</span><span class="p">,</span> <span class="n">p_L_up</span><span class="p">,</span> <span class="n">ss_std</span> <span class="o">=</span> <span class="n">sam</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">p_max</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">],</span> <span class="n">delta_max</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">],</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's plot and compare the two:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Multi-parameter-error-models">Multi-parameter error models<a class="anchor-link" href="#Multi-parameter-error-models"> </a></h1><p>Similarly, for a multi-parameter noise model all we have to do is specify the physical error rates for corresponding partitions and pass it to the sampler. Note that for now only two partitions are implemented (one for one-qubit gates and one for two-qubit gates).</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">p2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">p1</span>
<span class="n">err_params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;p1&#39;</span><span class="p">:</span> <span class="n">p1</span><span class="p">,</span> <span class="s1">&#39;p2&#39;</span><span class="p">:</span> <span class="n">p2</span><span class="p">}</span>
<span class="n">sam</span> <span class="o">=</span> <span class="n">DirectSampler</span><span class="p">(</span><span class="n">ghz</span><span class="p">,</span> <span class="n">err_params</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Subset-sampling-helper-functions">Subset sampling helper functions<a class="anchor-link" href="#Subset-sampling-helper-functions"> </a></h1><blockquote><p>Collection functions to support subset sampling.</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>First, let's talk about how to decide which subset to sample from during subset sampling. The simplest strategy would be to always select the subset which was sampled least in order to sample uniformly from every subset:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="uniform_select" class="doc_header"><code>uniform_select</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/samplers.py#L61" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>uniform_select</code>(<strong><code>counts</code></strong>, <strong>*<code>args</code></strong>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Return index of least sampled SS</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Alternatively, we can make a decision which is more informed on a) the occurance probability of subsets (i.e. the binomial weights $A_w$) and the current as well as prospective variances for sampling respective subsets. Selecting the weight for which the difference scaled by $A_w^2$ yields a maximum is the best next subset weight we can choose in order to reduce the global variance the most. This method is termed Expected Reduction of Variance (ERV):</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="ERV_select" class="doc_header"><code>ERV_select</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/samplers.py#L65" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>ERV_select</code>(<strong><code>counts</code></strong>, <strong><code>fail_counts</code></strong>, <strong><code>ss_factors</code></strong>=<em><code>1</code></em>, <strong><code>var</code></strong>=<em><code>Wilson_var</code></em>, <strong>*<code>args</code></strong>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Return index of SS which yields maximum ERV</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can compare the results of using the two methods.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calc_w_max" class="doc_header"><code>calc_w_max</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/samplers.py#L88" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calc_w_max</code>(<strong><code>p_max</code></strong>, <strong><code>delta_max</code></strong>, <strong><code>n_partition_elems</code></strong>)</p>
</blockquote>
<p>Calculate weight cutoff at p_max for delta_max.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calc_partition_weight_vecs" class="doc_header"><code>calc_partition_weight_vecs</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/samplers.py#L107" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calc_partition_weight_vecs</code>(<strong><code>p_max</code></strong>, <strong><code>delta_max</code></strong>, <strong><code>partitions</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calc_subset_occurances" class="doc_header"><code>calc_subset_occurances</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/samplers.py#L117" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calc_subset_occurances</code>(<strong><code>partitions</code></strong>, <strong><code>partition_weight_vecs</code></strong>, <strong><code>p_phys_mat</code></strong>)</p>
</blockquote>
<p>Calculate 3D tensor of binom. coefficients for each partition</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calc_statistics" class="doc_header"><code>calc_statistics</code><a href="https://github.com/dpwinter/qsam/tree/master/qsam/samplers.py#L125" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calc_statistics</code>(<strong><code>Aws</code></strong>, <strong><code>pws</code></strong>, <strong><code>n_samples</code></strong>, <strong><code>var</code></strong>=<em><code>Wilson_var</code></em>)</p>
</blockquote>
<p>Calculate upper and lower bounds on logical failure rate and standard deviation</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>


