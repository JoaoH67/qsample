# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_circuit.ipynb.

# %% auto 0
__all__ = ['GATES', 'unpack', 'draw_circuit', 'Circuit']

# %% ../nbs/03_circuit.ipynb 3
from collections.abc import MutableSequence
from functools import cached_property
from hashlib import sha1
import qiskit
import re
from qiskit.qasm3 import loads
import latextools
import stim

# %% ../nbs/03_circuit.ipynb 4
GATES = {
    "init": {"init"},
    "q1": {"I", "X", "Y", "Z", "H", "T", "Q", "Qd", "S", "Sd", "R", "Rd", "Rx", "Ry", "Rz"},
    "q2": {"CNOT", "MSd"},
    "meas": {"measure"}
}

# 
GATES_stim = {
    
    "q1": {"I", "X", "Y", "Z",
    "C_NXYZ", "C_NZYX", "C_XNYZ", "C_XYNZ", "C_XYZ", "C_ZNYX", "C_ZYNX", "C_ZYX",
    "H", "H_NXY", "H_NXZ", "H_NYZ", "H_XY", "H_XZ", "H_YZ",
    "S", "S_DAG",
    "SQRT_X", "SQRT_X_DAG", "SQRT_Y", "SQRT_Y_DAG", "SQRT_Z", "SQRT_Z_DAG"
                    }, 
        
    "q2":{"CNOT", "CX", "CXSWAP", "CY", "CZ", "CZSWAP",
    "II", "ISWAP", "ISWAP_DAG",
    "SQRT_XX", "SQRT_XX_DAG", "SQRT_YY", "SQRT_YY_DAG", "SQRT_ZZ", "SQRT_ZZ_DAG",
    "SWAP", "SWAPCX", "SWAPCZ",
    "XCX", "XCY", "XCZ", "YCX", "YCY", "YCZ", "ZCX", "ZCY", "ZCZ"
                            }, 
    
    "meas":{"M", "MR", "MRX", "MRY", "MRZ", "MX", "MY", "MZ", "R", "RX", "RY", "RZ", 
                    "MXX", "MYY", "MZZ", "MPP", "SPP", "SPP_DAG"}}

GATES_stim_unpacked = {
    
"I", "X", "Y", "Z",
    "C_NXYZ", "C_NZYX", "C_XNYZ", "C_XYNZ", "C_XYZ", "C_ZNYX", "C_ZYNX", "C_ZYX",
    "H", "H_NXY", "H_NXZ", "H_NYZ", "H_XY", "H_XZ", "H_YZ",
    "S", "S_DAG",
    "SQRT_X", "SQRT_X_DAG", "SQRT_Y", "SQRT_Y_DAG", "SQRT_Z", "SQRT_Z_DAG",
    "CNOT", "CX", "CXSWAP", "CY", "CZ", "CZSWAP",
    "II", "ISWAP", "ISWAP_DAG",
    "SQRT_XX", "SQRT_XX_DAG", "SQRT_YY", "SQRT_YY_DAG", "SQRT_ZZ", "SQRT_ZZ_DAG",
    "SWAP", "SWAPCX", "SWAPCZ",
    "XCX", "XCY", "XCZ", "YCX", "YCY", "YCZ", "ZCX", "ZCY", "ZCZ",
    "M", "MR", "MRX", "MRY", "MRZ", "MX", "MY", "MZ", "R", "RX", "RY", "RZ", 
                    "MXX", "MYY", "MZZ", "MPP", "SPP", "SPP_DAG"}


stim2qs_GATES = {
    "I":("I",), "X":("X",), "Y":("Y",), "Z":("Z",),
    "H":("H",), "S":("S",), "S_DAG":("Sd",),
    "SQRT_X":("Q",), "SQRT_X_DAG":("Qd",), "SQRT_Y":("R",), "SQRT_Y_DAG":("Rd",), "SQRT_Z":("S",), "SQRT_Z_DAG":("Sd",),
    "CX":("CNOT",), "CNOT":("CNOT",),
    "M":("measure",), "R":("init",), "MR":("measure", "init"), "RX":("init", "H"), "MX": ("H", "measure")
}

qs2stim_GATES = {
    "I":"I", "X":"X", "Y":"Y", "Z":"Z",
    "H":"H", "S":"S", "Sd":"S_DAG",
    "Q":"SQRT_X", "Qd":"SQRT_X_DAG", "R":"SQRT_Y", "Rd":"SQRT_Y_DAG", "S":"SQRT_Z", "Sd":"SQRT_Z_DAG",
    "CNOT":"CNOT"
}

qiskit2qs_GATES = {
    "I":"I", "x":"X", "y":"Y", "z":"Z",
    "h":"H","cx":"CNOT","measure":"measure","reset":"init"
}

# %% ../nbs/03_circuit.ipynb 5
def unpack(seq):
    """Generator to unpack all values of dicts inside
    a list of dicts
    
    Parameters
    ----------
    seq : Iterable
        Iterable to recursively unpack
    """
    
    if isinstance(seq, (tuple,set,list,Circuit)):
        yield from (x for y in seq for x in unpack(y))
    elif isinstance(seq, dict):
        yield from (x for v in seq.values() for y in v for x in unpack(y))
    else:
        yield seq

# %% ../nbs/03_circuit.ipynb 6
def draw_circuit(circuit, path=None, scale=2):
    """Draw circuit using `latextools` library
    
    Parameters
    ----------
    circuit : Circuit
        The circuit to draw
    path : str or None
        The path to save the resulting image to (optional)
    scale : int
        The scale of the image
        
    Returns
    -------
    drawSvg.drawing.Drawing
        Image object
    """
    
    n_qubits = max(unpack(circuit)) + 1
    cmat = [["",""] + [r"\qw" for _ in range(circuit.n_ticks - 1)] for _ in range(n_qubits)]

    for col, tick in enumerate(circuit,1):
        for gate, qbs in tick.items():
            if gate in GATES['q2']:
                for qbtup in qbs:
                    ctrl, targ = qbtup[0], qbtup[1]
                    delta = targ - ctrl

                    cmat[ctrl][col] = r"\ctrl{%d}" % delta
                    sym = r"\targ" if gate == "CNOT" else r"\gate{%s}" % gate
                    cmat[targ][col] = sym
                continue
            elif gate == "measure": sym = r"\meter"
            elif gate == "init": sym = r"\push{\ket{0}}"

            elif gate in GATES['q1']: 
                sym = r"\gate{%s}" % gate
            else:
                raise Exception(f'Unknown gate {gate}')

            for row in qbs:
                cmat[row][col] = sym

    tex_str = r"\\".join([" & ".join([e for e in row]) for row in cmat])
    pdf = latextools.render_qcircuit(tex_str, const_row=False, const_col=True)
    svg = pdf.as_svg().as_drawing(scale=scale)
    if path: svg.saveSvg(path)
    return svg

def pair_elements(lst): # Helper function for converting 2 qubit gates from QSample to STIM
    return [{(lst[i], lst[i + 1])} for i in range(0, len(lst), 2)]

def extract_detector_measurements(stim_str):
    """
    Extracts the measurement dependencies for each DETECTOR in a stim circuit.

    Args:
        stim_str: The stim circuit string.

    Returns:
        result: A 2D list where each row corresponds to a DETECTOR and contains
                    the measurement indices (relative 'rec' values) used in that detector.
    """
    result = []
    combined_measurements = []
    ordered_measurements = []
    for instruction in stim_str.split('\n'):
        instruction_list = instruction.split(' ')
        detector_instruction=False
        measurement_instruction=False
        
        for ii in instruction_list:
            if (not detector_instruction) and (not measurement_instruction):
                d_match = re.findall(r'DETECTOR', ii)
                if d_match:
                    detector_measurements = []
                    detector_instruction = True
                
                m_match = re.findall(r'M', ii)
                if m_match:
                    measurement_list=[]
                    measurement_instruction=True
            
            elif detector_instruction:
                match = re.findall(r"rec\[(\-?\d+)\]", ii)
                if match:
                    detector_measurements.append(combined_measurements[int(match[0])])
            
            elif measurement_instruction:
                if len(ii)>0:
                    measurement_list.append(int(ii))
        
        if detector_instruction:
            result.append(detector_measurements)
        
        if measurement_instruction:
            combined_measurements.extend(measurement_list)
            ordered_measurements.extend(sorted(measurement_list))
                
    
    for i in range(len(result)):
        for j in range(len(result[i])):
            result[i][j]=ordered_measurements.index(result[i][j])

    return result

# %% ../nbs/03_circuit.ipynb 7
class Circuit(MutableSequence):
    """Representation of a quantum circuit
    
    Attributes
    ----------
    _ticks : list of dict
        List of ticks in the circuit
    noisy : bool
        If true, circuit is subject to noise during sampling
    ff_deterministic : bool
        If true, the measurement result of the circuit in the
        fault-free case is always deterministic
    qubits : set
        Set of qubits "touched" by circuit
    n_qubits : int
        Numbers of qubits "touched" by circuit
    n_ticks : int
        Number of ticks in circuit
    id : str
        Unique circuit identifier
    """
    
    def __init__(self, ticks=None, noisy=True):
        """
        Parameters
        ----------
        ticks : list
            List of ticks defining a circuit
        noisy : bool
            If true, circuit is subject to noise during sampling
        """
        self._ticks = ticks if ticks else [] # Must do this way, else keeps appending to same instance
        self.noisy = noisy
    
    
    
    def from_stim_circuit(self, stim_str):
        if isinstance(stim_str, stim.Circuit):
            self.dem = stim_str.detector_error_model()
            stim_str = repr(stim_str)
        else:
            self.dem = stim.Circuit(stim_str).detector_error_model()
        self.detector_array = extract_detector_measurements(stim_str)
        self._ticks = ["foo"]
        
        
        repeat_instruction = False
        n_repeats = 1
        tick_list = []
        
        name = None
        
        for instruction in stim_str.split('\n'):
            instruction_list = instruction.split(' ')
            
            is_target = False
            valid_gate = False
            target_list = []
            
            for i in instruction_list:
                if len(i)!=0 and not is_target: # First non-empty element in array is the gate name
                    name = i
                    is_target = True
                    
                    if name == "REPEAT":    # Open repeat block
                        repeat_instruction = True
                    elif name == "}":       # Close repeat block
                        repeat_instruction = False
                        
                    elif name in GATES_stim_unpacked:
                        valid_gate=True
                    
                    
                
                elif len(i)!=0 and (name=="REPEAT"): # The following number is the number of repetitions
                    try:
                        n_repeats = int(i)
                    except: # It is an opening bracket '{'
                        pass 
                
                elif len(i)!=0 and valid_gate and is_target and not (name=="REPEAT"):  # The following number is a gate target
                    target_list.append(int(i))

                    
                    
            if valid_gate:  # If it is an actual gate in STIM, not an instruction like 'DETECTOR' or 'X_ERROR', add equivalent qsample gate and target to gate buffer
                try:
                    qs_gates = stim2qs_GATES[name]
                except KeyError:
                    print("Gate {} not implemented in QSample".format(name))
                    break
                        
                if name in GATES_stim["q2"]:
                    target_list = pair_elements(target_list)
                else:
                    target_list = [set(target_list)]
                for gate in qs_gates:
                    for target in target_list:
                        tick_list.append({gate: target})
                        
            if not repeat_instruction: # Apply gates from gate buffer and reset repeat block
                for j in range(n_repeats):
                    for tick in tick_list:
                        self._ticks.insert(-1, tick)
                n_repeats = 1
                tick_list = []
                

        self.__delitem__(-1) # Remove foo gate
        return self  
    
    def from_qasm_circuit(self, qasm_str):
        qc =qiskit.QuantumCircuit.from_qasm_str(qasm_str)
        self._ticks = ["foo"]

        for instr, qargs, _ in qc.data:
            name = instr.name
            qubits = [q._index for q in qargs]
            
            try:
                qs_gate = qiskit2qs_GATES[name]
                if len(qubits)==2:
                    target = (qubits[0],qubits[1])
                else:
                    target = qubits[0]
                tick = {qs_gate: {target}}
                self._ticks.insert(-1, tick)
            except KeyError:
                raise ValueError(f"No correspondence found for: {name}")
                break

        self.__delitem__(-1)
        return self
    
    def from_qiskit_circuit(self, qc):
        self._ticks = ["foo"]

        for instr, qargs, _ in qc.data:
            name = instr.name
            qubits = [q._index for q in qargs]
            
            try:
                qs_gate = qiskit2qs_GATES[name]
                if len(qubits)==2:
                    target = (qubits[0],qubits[1])
                else:
                    target = qubits[0]
                tick = {qs_gate: {target}}
                self._ticks.insert(-1, tick)
            except KeyError:
                raise ValueError(f"No correspondence found for: {name}")
                break

        self.__delitem__(-1)
        return self
        
    @cached_property
    def to_stim_circuit(self):  
        """Cached STIM circuit"""
        return stim.Circuit(qs2stim(self))


            
    def __getitem__(self, tick_index):
        return self._ticks[tick_index]
    
    def __setitem__(self, tick_index, tick):
        self._ticks[tick_index] = tick
        
    def __delitem__(self, tick_index):
        del self._ticks[tick_index]
        
    def __len__(self):
        return len(self._ticks)
    
    def insert(self, tick_index, tick):
        """Insert a tick into a circuit
        
        Parameters
        ----------
        tick_index : int
            Index at which tick is inserted (tick indices to right incremented by 1)
        tick : dict
            Tick dictionary to insert
        """
        self._ticks.insert(tick_index, tick)
    
    def __str__(self):
        if self._ticks == []:
            return "__empty__"
        str_list = []
        for i, tick in enumerate(self._ticks):
            str_list.append(f"{i}: {str(tick)}")
        return "\n".join(str_list)
    
    @cached_property
    def qubits(self):  
        """Set of qubits used in circuit"""
        return set(unpack(self._ticks))
    
    @cached_property
    def n_qubits(self):
        """Number of qubits used in circuit"""
        # JOAO: modified this to accomodate stim built-in circuits
        return max(self.qubits)+1
    
    @cached_property
    def n_ticks(self):
        """Number of ticks"""
        return len(self._ticks)
    
    @cached_property    
    def measured_qubits(self):
        """Set of qubits measured in circuit"""
        measured_qubits = set()
        for i, tick in enumerate(self._ticks):
            if list(tick.keys())[0] == "measure":
                measured_qubits.update(list(tick.values())[0])
                        
        return list(measured_qubits)
    
    @cached_property 
    def n_measurements(self):
        """Number of measured qubits in the circuit"""
        return len(self.measured_qubits)
    
    @property
    def id(self):
        """Unique circuit identifier"""
        return sha1((repr(self)).encode('UTF-8')).hexdigest()[:5]

    def draw(self, path=None, scale=2):
        """Draw the circuit"""
        return draw_circuit(self, path, scale)

    
    
def qs2stim(circuit):
    stim_circuit = ""
    for tick in circuit._ticks:
        for name in list(tick.keys()):
        
            if name in GATES["q1"]:
                try:
                    instruction = qs2stim_GATES[name]+" "
                except KeyError:
                    print("Gate {} not implemented in STIM".format(name))
                    break
                for i in list(tick.values())[0]:
                    instruction += str(i)
                    instruction += " "
                stim_circuit+=(instruction+"\n")

            if name in GATES["q2"]:
                try:
                    instruction = qs2stim_GATES[name]+" "
                except KeyError:
                    print("Gate {} not implemented in STIM".format(name))
                    break
                for i in list(tick.values())[0]:
                    instruction += (str(i[0])+ " " + str(i[1]) + "\n")
                    #instruction += "TICK"
                stim_circuit+=(instruction+"\n")

            if name in GATES["meas"]:
                instruction = "M "
                for i in list(tick.values())[0]:
                    instruction += str(i)
                    instruction += " "
                stim_circuit+=(instruction+"\n")

            if name in GATES["init"]:
                instruction = "R "
                for i in list(tick.values())[0]:
                    instruction += str(i)
                    instruction += " "
                stim_circuit+=(instruction+"\n")
                
    return stim_circuit
